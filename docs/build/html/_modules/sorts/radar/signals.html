
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sorts.radar.signals &#8212; SORTS v4.0 Manual</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "dark";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="None">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="dark">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    <p class="title logo__title">SORTS v4.0 Manual</p>
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../intro.html">
  Introduction
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../install.html">
  Installation
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../usermanual.html">
  SORTS Manual
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/danielk333/sorts" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <h1>Source code for sorts.radar.signals</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39; This module is used to define the radar network configuration. &#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span>

<div class="viewcode-block" id="hard_target_snr_scaling"><a class="viewcode-back" href="../../../reference/radar/signals/auto/sorts.radar.signals.hard_target_snr_scaling.html#sorts.radar.signals.hard_target_snr_scaling">[docs]</a><span class="k">def</span> <span class="nf">hard_target_snr_scaling</span><span class="p">(</span><span class="n">diameter_from</span><span class="p">,</span> <span class="n">diameter_to</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Determine the **scaling constant** `c` to convert the SNR generated by a </span>
<span class="sd">    `diameter_from` target to a `diameter_to` target.</span>

<span class="sd">    The constant is computed by solving the equation :</span>

<span class="sd">    .. math::       SNR(R_1) = c SNR(R_2)</span>

<span class="sd">    For each of the possible scattering regimes (i.e. **Rayleigh** and **Optical**).</span>
<span class="sd">    </span>
<span class="sd">    .. rubric:: Syntax</span>
<span class="sd"> </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    diameter_from : float / numpy.ndarray</span>
<span class="sd">        object diameter of snr to convert from (in *meters*).</span>
<span class="sd">    diameter_to : float / numpy.ndarray</span>
<span class="sd">        object diameter of snr to convert to (in *meters*).</span>
<span class="sd">    wavelength : float / numpy.ndarray</span>
<span class="sd">        radar wavelength (in *meters*).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float/numpy.ndarray</span>
<span class="sd">        scaling constant `c` to convert the SNR generated by a `diameter_from` target to </span>
<span class="sd">        a `diameter_to` target.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider a *monostatic* radar operating at 500 MHz observing a target with a diameter </span>
<span class="sd">    of 1m. The scaling constant by which we need to multiply the SNR of the target of diameter</span>
<span class="sd">    1m to get the SNR of the target of 2m can be computed as follows:</span>

<span class="sd">    &gt;&gt;&gt; import sorts</span>
<span class="sd">    &gt;&gt;&gt; sorts.signals.hard_target_snr_scaling(1, 2, 0.6)</span>
<span class="sd">    64.0</span>

<span class="sd">    So a target of diameter 2m at 500 MHz has a SNR 64 times greater than a target of diameter</span>
<span class="sd">    1m.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">sep_const</span> <span class="o">=</span> <span class="n">wavelength</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">diameter_from</span> <span class="o">&lt;</span> <span class="n">sep_const</span> <span class="ow">and</span> <span class="n">diameter_to</span> <span class="o">&lt;</span> <span class="n">sep_const</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">diameter_to</span><span class="o">**</span><span class="mi">6</span><span class="o">/</span><span class="n">diameter_from</span><span class="o">**</span><span class="mi">6</span>
    <span class="k">elif</span> <span class="n">diameter_from</span> <span class="o">&lt;</span> <span class="n">sep_const</span> <span class="ow">and</span> <span class="n">diameter_to</span> <span class="o">&gt;=</span> <span class="n">sep_const</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">wavelength</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">diameter_to</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">9</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">diameter_from</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">diameter_from</span> <span class="o">&gt;=</span> <span class="n">sep_const</span> <span class="ow">and</span> <span class="n">diameter_to</span> <span class="o">&lt;</span> <span class="n">sep_const</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="mi">9</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">diameter_to</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">wavelength</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">diameter_from</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">diameter_to</span><span class="o">**</span><span class="mi">6</span><span class="o">/</span><span class="n">diameter_from</span><span class="o">**</span><span class="mi">6</span>

    <span class="k">return</span> <span class="n">scale</span></div>


<div class="viewcode-block" id="hard_target_rcs"><a class="viewcode-back" href="../../../reference/radar/signals/auto/sorts.radar.signals.hard_target_rcs.html#sorts.radar.signals.hard_target_rcs">[docs]</a><span class="k">def</span> <span class="nf">hard_target_rcs</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">diameter</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Compute the **Radar Cross-Section** (RCS) for a hard target.</span>
<span class="sd">    </span>
<span class="sd">    The implementation is based upon the assumption of a smooth transition between </span>
<span class="sd">    the **Rayleigh** and **optical** scattering regimes. For simplification puroposes, it ignores </span>
<span class="sd">    the *Mie* oscillatory regime and use either optical or Rayleigh scatter with the transition</span>
<span class="sd">    at </span>

<span class="sd">    ..math::        D = \\frac{\\lambda}{\\pi \\sqrt{3}}</span>

<span class="sd">    Please refer to :ref:`_signals-theory-rcs` for more information.</span>
<span class="sd">    </span>
<span class="sd">    .. rubric:: Syntax</span>
<span class="sd"> </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wavelength : float / numpy.ndarray</span>
<span class="sd">        Radar wavelength (in *meters*).</span>
<span class="sd">    diameter: float / numpy.ndarray</span>
<span class="sd">        Diameter of the objects (in *meters*).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float/numpy.ndarray :</span>
<span class="sd">        Estimated **Radar Cross-Section** (RCS) of the objects being observed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider a *monostatic* radar operating at 500 MHz observing a target with a diameter of 10cm. </span>
<span class="sd">    We can compute the estimated target RCS as follows:</span>

<span class="sd">    &gt;&gt;&gt; import sorts</span>
<span class="sd">    &gt;&gt;&gt; sorts.signals.hard_target_rcs(0.6, 0.1)</span>
<span class="sd">    0.005312841749744471</span>

<span class="sd">    So a target of diameter 10 cm at 500 MHz has a RCS value of :math:`0.005 m^2`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># masks</span>
    <span class="n">is_rayleigh</span> <span class="o">=</span> <span class="n">diameter</span> <span class="o">&lt;</span> <span class="n">wavelength</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>
    <span class="n">is_optical</span> <span class="o">=</span> <span class="n">diameter</span> <span class="o">&gt;=</span> <span class="n">wavelength</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>
    
    <span class="c1"># optical regime rcs</span>
    <span class="n">optical_rcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">diameter</span><span class="o">**</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">4.0</span>

    <span class="c1"># rayleigh regime rcs</span>
    <span class="n">rayleigh_rcs</span> <span class="o">=</span> <span class="mf">9.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mf">5.0</span><span class="o">*</span><span class="n">diameter</span><span class="o">**</span><span class="mf">6.0</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">wavelength</span><span class="o">**</span><span class="mf">4.0</span><span class="p">)</span>
    
    <span class="n">rcs</span> <span class="o">=</span> <span class="n">is_rayleigh</span><span class="o">*</span><span class="n">rayleigh_rcs</span> <span class="o">+</span> <span class="n">is_optical</span><span class="o">*</span><span class="n">optical_rcs</span>
    <span class="k">return</span> <span class="n">rcs</span> </div>


<div class="viewcode-block" id="hard_target_snr"><a class="viewcode-back" href="../../../reference/radar/signals/auto/sorts.radar.signals.hard_target_snr.html#sorts.radar.signals.hard_target_snr">[docs]</a><span class="k">def</span> <span class="nf">hard_target_snr</span><span class="p">(</span>
        <span class="n">gain_tx</span><span class="p">,</span> 
        <span class="n">gain_rx</span><span class="p">,</span>
        <span class="n">wavelength</span><span class="p">,</span>
        <span class="n">power_tx</span><span class="p">,</span>
        <span class="n">range_tx_m</span><span class="p">,</span> 
        <span class="n">range_rx_m</span><span class="p">,</span>
        <span class="n">diameter</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> 
        <span class="n">bandwidth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">rx_noise_temp</span><span class="o">=</span><span class="mf">150.0</span><span class="p">,</span>
        <span class="n">radar_albedo</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Compute the signal-to-noise ratio for a hard target.</span>

<span class="sd">    A smooth transition between **Rayleigh** and **optical** scattering is assumed,  </span>
<span class="sd">    Therefore ignoring the *Mie regime*.</span>

<span class="sd">    The equation for the SNR is obtained by combining the expressions of the RCS for</span>
<span class="sd">    each scattering regimes (Optical/Rayleigh) given in :ref:`signals-theory-rcs`, </span>
<span class="sd">    and the expressions of the Noise power given in :ref:`signals-theory-snr` to compute </span>
<span class="sd">    the SNR.</span>

<span class="sd">    .. rubric:: Syntax</span>
<span class="sd"> </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gain_tx : float / numpy.ndarray</span>
<span class="sd">        Transmit antenna gain, linear</span>
<span class="sd">    gain_rx : float / numpy.ndarray</span>
<span class="sd">        Receiver antenna gain, linear</span>
<span class="sd">    wavelength : float / numpy.ndarray</span>
<span class="sd">        Radar wavelength (meters)</span>
<span class="sd">    power_tx : float / numpy.ndarray</span>
<span class="sd">        Transmit power (W)</span>
<span class="sd">    range_tx_m : float / numpy.ndarray</span>
<span class="sd">        Range from transmitter to target (meters)</span>
<span class="sd">    range_rx_m : float / numpy.ndarray</span>
<span class="sd">        Range from target to receiver (meters)</span>
<span class="sd">    diameter : float / numpy.ndarray</span>
<span class="sd">        Object diameter (meters)</span>
<span class="sd">    bandwidth : float / numpy.ndarray</span>
<span class="sd">        Effective receiver noise bandwidth</span>
<span class="sd">    rx_noise_temp: float / numpy.ndarray</span>
<span class="sd">        Receiver noise temperature (K)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float / numpy.ndarray</span>
<span class="sd">        Estimated *Signal-to-Noise Ratio*</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Measurements of small-size debris with backscatter of radio waves, J. Markkanen </span>
<span class="sd">    et al., 1999, ESA contract report</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider a *monostatic* radar of bandwidth 10 Hz, gain 40 dB, noise temperature 150 K </span>
<span class="sd">    observing an object situated at a range 1000 km at frequency 500 MHz and power 5 MW. </span>
<span class="sd">    Supposing that we get a SNR value of 44 dB, the function ``hard_target_diameter`` </span>
<span class="sd">    will return the following result:</span>

<span class="sd">    &gt;&gt;&gt; import sorts</span>
<span class="sd">    &gt;&gt;&gt; sorts.signals.hard_target_snr(1e4, 1e4, 0.6, 5e6, 1000e3, 1000e3, 0.1, bandwidth=10, rx_noise_temp=150.0, radar_albedo=1.0)</span>
<span class="sd">    23269.93934963154</span>
<span class="sd">    &gt;&gt;&gt; 10*np.log10(23269.93934963154)</span>
<span class="sd">    43.6679525135056</span>

<span class="sd">    So a target of diameter 10 cm will produce a SNR value of approximately 44 dB under </span>
<span class="sd">    the previously described configuration.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">is_rayleigh</span> <span class="o">=</span> <span class="n">diameter</span> <span class="o">&lt;</span> <span class="n">wavelength</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>
    <span class="n">is_optical</span> <span class="o">=</span> <span class="n">diameter</span> <span class="o">&gt;=</span> <span class="n">wavelength</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>

    <span class="n">rayleigh_power</span> <span class="o">=</span> <span class="p">(</span><span class="mf">9.0</span><span class="o">*</span><span class="n">power_tx</span><span class="o">*</span><span class="p">(((</span><span class="n">gain_tx</span><span class="o">*</span><span class="n">gain_rx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">diameter</span><span class="o">**</span><span class="mf">6.0</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mf">256.0</span><span class="o">*</span><span class="p">(</span><span class="n">wavelength</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">range_rx_m</span><span class="o">**</span><span class="mf">2.0</span><span class="o">*</span><span class="n">range_tx_m</span><span class="o">**</span><span class="mf">2.0</span><span class="p">))))</span>
    <span class="n">optical_power</span> <span class="o">=</span> <span class="p">(</span><span class="n">power_tx</span><span class="o">*</span><span class="p">(((</span><span class="n">gain_tx</span><span class="o">*</span><span class="n">gain_rx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">wavelength</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">diameter</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)))</span><span class="o">/</span><span class="p">(</span><span class="mf">256.0</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">range_rx_m</span><span class="o">**</span><span class="mf">2.0</span><span class="o">*</span><span class="n">range_tx_m</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)))</span>
    
    <span class="n">rx_noise</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="n">rx_noise_temp</span><span class="o">*</span><span class="n">bandwidth</span>
    <span class="n">snr</span> <span class="o">=</span> <span class="p">((</span><span class="n">is_rayleigh</span><span class="p">)</span><span class="o">*</span><span class="n">rayleigh_power</span> <span class="o">+</span> <span class="p">(</span><span class="n">is_optical</span><span class="p">)</span><span class="o">*</span><span class="n">optical_power</span><span class="p">)</span><span class="o">*</span><span class="n">radar_albedo</span><span class="o">/</span><span class="n">rx_noise</span>

    <span class="k">return</span> <span class="n">snr</span></div>

<div class="viewcode-block" id="hard_target_diameter"><a class="viewcode-back" href="../../../reference/radar/signals/auto/sorts.radar.signals.hard_target_diameter.html#sorts.radar.signals.hard_target_diameter">[docs]</a><span class="k">def</span> <span class="nf">hard_target_diameter</span><span class="p">(</span>
            <span class="n">gain_tx</span><span class="p">,</span> 
            <span class="n">gain_rx</span><span class="p">,</span>
            <span class="n">wavelength</span><span class="p">,</span>
            <span class="n">power_tx</span><span class="p">,</span>
            <span class="n">range_tx_m</span><span class="p">,</span> 
            <span class="n">range_rx_m</span><span class="p">,</span>
            <span class="n">snr</span><span class="p">,</span> 
            <span class="n">bandwidth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">rx_noise_temp</span><span class="o">=</span><span class="mf">150.0</span><span class="p">,</span>
            <span class="n">radar_albedo</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Determine the diameter for a hard target based on the Signal-to-Noise Ratio (SNR).</span>
<span class="sd">    A smooth transition between **Rayleigh** and **optical** scattering is assumed,  </span>
<span class="sd">    Therefore ignoring the *Mie regime*.</span>

<span class="sd">    The equation for the object diameter is obtained by combining the expressions of the RCS for</span>
<span class="sd">    each scattering regimes (Optical/Rayleigh) given in :ref:`signals-theory-rcs`, </span>
<span class="sd">    and the expressions of the Noise power given in :ref:`signals-theory-snr` to compute </span>
<span class="sd">    the SNR.</span>

<span class="sd">    .. rubric:: Syntax</span>
<span class="sd"> </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gain_tx : float / numpy.ndarray</span>
<span class="sd">        Transmit antenna gain (-).</span>
<span class="sd">    gain_rx : float / numpy.ndarray</span>
<span class="sd">        Receiver antenna gain (-).</span>
<span class="sd">    wavelength : float / numpy.ndarray</span>
<span class="sd">        Radar wavelength (m).</span>
<span class="sd">    power_tx : float / numpy.ndarray</span>
<span class="sd">        Transmit power (W).</span>
<span class="sd">    range_tx_m : float / numpy.ndarray</span>
<span class="sd">        Range from transmitter to target (m).</span>
<span class="sd">    range_rx_m : float/ n umpy.ndarray</span>
<span class="sd">        Range from target to receiver (m).</span>
<span class="sd">    snr : float / numpy.ndarray</span>
<span class="sd">        Object signal to noise ratio (-).</span>
<span class="sd">    bandwidth : float / numpy.ndarray</span>
<span class="sd">        Effective receiver noise bandwidth (Hz).</span>
<span class="sd">    rx_noise_temp : float / numpy.ndarray</span>
<span class="sd">        Receiver noise temperature (K).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float / numpy.ndarray</span>
<span class="sd">        Object diameter (in meters).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Measurements of small-size debris with backscatter of radio waves, J. </span>
<span class="sd">    Markkanen et. al., 1999, ESA contract report</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider a *monostatic* radar of bandwidth 10 Hz, gain 40 dB, noise temperature </span>
<span class="sd">    150 K observing an object situated at a range 1000 km at frequency 500 MHz and </span>
<span class="sd">    power 5 MW. Supposing that we get a SNR value of 44 dB, the function </span>
<span class="sd">    ``hard_target_diameter`` will return the following result:</span>

<span class="sd">    &gt;&gt;&gt; import sorts</span>
<span class="sd">    &gt;&gt;&gt; sorts.signals.hard_target_diameter(1e4, 1e4, 0.6, 5e6, 1000e3, 1000e3, 10**(44/10.0), bandwidth=10, rx_noise_temp=150.0, radar_albedo=1.0):</span>
<span class="sd">    0.1012824328560151</span>

<span class="sd">    So the target diameter needed to produce a SNR value of :math:`44 dB` with </span>
<span class="sd">    the previously described configuration is 10 cm</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">rx_noise</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="n">rx_noise_temp</span><span class="o">*</span><span class="n">bandwidth</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">snr</span><span class="o">*</span><span class="n">rx_noise</span><span class="o">/</span><span class="n">radar_albedo</span>

    <span class="n">diameter_rayleigh</span> <span class="o">=</span> <span class="p">(</span><span class="mf">256.0</span><span class="o">*</span><span class="p">(</span><span class="n">wavelength</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">range_rx_m</span><span class="o">**</span><span class="mf">2.0</span><span class="o">*</span><span class="n">range_tx_m</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="n">power</span><span class="o">/</span><span class="p">(</span><span class="mf">9.0</span><span class="o">*</span><span class="n">power_tx</span><span class="o">*</span><span class="p">(</span><span class="n">gain_tx</span><span class="o">*</span><span class="n">gain_rx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)))</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="n">diameter_optical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">256.0</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">range_rx_m</span><span class="o">**</span><span class="mf">2.0</span><span class="o">*</span><span class="n">range_tx_m</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="n">power</span><span class="o">/</span><span class="p">(</span><span class="n">power_tx</span><span class="o">*</span><span class="p">(</span><span class="n">gain_tx</span><span class="o">*</span><span class="n">gain_rx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">wavelength</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)))</span>

    <span class="n">separatrix</span> <span class="o">=</span> <span class="n">wavelength</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>

    <span class="n">is_rayleigh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">diameter_rayleigh</span> <span class="o">&lt;</span> <span class="n">separatrix</span><span class="p">,</span> <span class="n">diameter_optical</span> <span class="o">&lt;</span> <span class="n">separatrix</span><span class="p">)</span>
    <span class="n">is_optical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">diameter_rayleigh</span> <span class="o">&gt;=</span> <span class="n">separatrix</span><span class="p">,</span> <span class="n">diameter_optical</span> <span class="o">&gt;=</span> <span class="n">separatrix</span><span class="p">)</span>

    <span class="n">diameter</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_rayleigh</span><span class="p">)</span><span class="o">*</span><span class="n">diameter_rayleigh</span> <span class="o">+</span> <span class="p">(</span><span class="n">is_optical</span><span class="p">)</span><span class="o">*</span><span class="n">diameter_optical</span>

    <span class="k">return</span> <span class="n">diameter</span></div>

<div class="viewcode-block" id="incoherent_snr"><a class="viewcode-back" href="../../../reference/radar/signals/auto/sorts.radar.signals.incoherent_snr.html#sorts.radar.signals.incoherent_snr">[docs]</a><span class="k">def</span> <span class="nf">incoherent_snr</span><span class="p">(</span><span class="n">signal_power</span><span class="p">,</span> <span class="n">noise_power</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">incoherent_integration_time</span><span class="o">=</span><span class="mf">3600.0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    Compute the **incoherent Signal-to-Noise Ratio** and the **minimal observation time** required.</span>

<span class="sd">    .. rubric:: Theorical background</span>

<span class="sd">    The **Signal-to-Noise Ratio** after performing an incoherent integration over an observation period </span>
<span class="sd">    :math:`\\tau_{obs}` can be expressed as:</span>

<span class="sd">    .. math:: SNR_{inc} = \\frac{P_s}{P_{N,inc}} \\sqrt{B_{inc} \\tau_{obs}}</span>

<span class="sd">    where :math:`P_{N,inc} = \\frac{k_B T_{tx} B_{inc}}{\\eta}` is the incoherent noise power.</span>

<span class="sd">    The **minimal observation time** :math:`\\tau_{obs}` is the time interval needed to achieve a</span>
<span class="sd">    probability of false detection :math:`\\epsilon` such as:</span>

<span class="sd">    .. math:: \\tau_{obs} = \\frac{(P_s + P_{N,inc})^2}{\\epsilon^2 P_s^2 B_{inc}}</span>
<span class="sd">    </span>
<span class="sd">    .. rubric:: Syntax</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal_power : float / numpy.ndarray</span>
<span class="sd">        Signal power (W).</span>
<span class="sd">    noise_power : float</span>
<span class="sd">        Noise power (W).</span>
<span class="sd">    epsilon : float</span>
<span class="sd">        Statistical significance criterion for a detection (-).</span>
<span class="sd">    bandwidth : float</span>
<span class="sd">        Measurement bandwidth (Hz).</span>
<span class="sd">    incoherent_integration_time : float</span>
<span class="sd">        Range from transmitter to target (meters).</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    snr : float / numpy.ndarray</span>
<span class="sd">        Signal to noise ratio (-)</span>
<span class="sd">    snr_incoh : float / numpy.ndarray</span>
<span class="sd">        Incoherent signal to noise ratio (-)</span>
<span class="sd">    minimal_observation_time : float / numpy.ndarray</span>
<span class="sd">        Minimal observation time (s)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Radar observability of near-Earth objects with EISCAT 3D, D. Kastinen et. al., 2020</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    If we consider a received signal of power :math:`15 \\cdot 10^{-19} W`, of incoherent </span>
<span class="sd">    integration bandwidth 10 Hz, incoherently integrated over a time period of </span>
<span class="sd">    3600 seconds with a noise power of :math:`2.1 \\cdot 10^{-20} W`, we have:</span>

<span class="sd">    &gt;&gt;&gt; import sorts</span>
<span class="sd">    &gt;&gt;&gt; sorts.incoherent_snr(15e-19, 2.1e-20, epsilon=0.05, bandwidth=10.0, incoherent_integration_time=3600.0)</span>
<span class="sd">    (71.42857142857143, 13552.618543578768, 41.127839999999985)</span>

<span class="sd">    Here, we have set a confidence level to get a 5% probability of false detection, which yields </span>
<span class="sd">    an SNR value of 18.5 dB, an incoherent SNR value of 41.3 dB and a minimal observation time of </span>
<span class="sd">    41.1 seconds.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Compute the signal to noise ratio</span>
    <span class="n">snr</span> <span class="o">=</span> <span class="n">signal_power</span><span class="o">/</span><span class="n">noise_power</span>
    
    <span class="c1"># compute the minimum required observation time needed to reduce the relative error to epsilon as follows</span>
    <span class="n">minimal_observation_time</span> <span class="o">=</span> <span class="p">((</span><span class="n">signal_power</span> <span class="o">+</span> <span class="n">noise_power</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">epsilon</span><span class="o">**</span><span class="mf">2.0</span><span class="o">*</span><span class="n">signal_power</span><span class="o">**</span><span class="mf">2.0</span><span class="o">*</span><span class="n">bandwidth</span><span class="p">)</span>
    
    <span class="c1"># Compute the incoherent signal to noise ratio</span>
    <span class="n">n_measurement</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">incoherent_integration_time</span> <span class="o">*</span> <span class="n">bandwidth</span><span class="p">)</span>
    <span class="n">snr_incoh</span> <span class="o">=</span> <span class="n">snr</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_measurement</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">snr</span><span class="p">,</span> <span class="n">snr_incoh</span><span class="p">,</span> <span class="n">minimal_observation_time</span></div>

<div class="viewcode-block" id="doppler_spread_hard_target_snr"><a class="viewcode-back" href="../../../reference/radar/signals/auto/sorts.radar.signals.doppler_spread_hard_target_snr.html#sorts.radar.signals.doppler_spread_hard_target_snr">[docs]</a><span class="k">def</span> <span class="nf">doppler_spread_hard_target_snr</span><span class="p">(</span>
        <span class="n">t_obs</span><span class="p">,</span> 
        <span class="n">spin_period</span><span class="p">,</span> 
        <span class="n">gain_tx</span><span class="p">,</span> 
        <span class="n">gain_rx</span><span class="p">,</span>
        <span class="n">wavelength</span><span class="p">,</span>
        <span class="n">power_tx</span><span class="p">,</span>
        <span class="n">range_tx_m</span><span class="p">,</span> 
        <span class="n">range_rx_m</span><span class="p">,</span>
        <span class="n">duty_cycle</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
        <span class="n">diameter</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> 
        <span class="n">bandwidth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">rx_noise_temp</span><span class="o">=</span><span class="mf">150.0</span><span class="p">,</span>
        <span class="n">radar_albedo</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Compute the **coherent** and **incoherent** Signal-to-Noise ratio for a spinning rigid object by taking </span>
<span class="sd">    into account the *Doppler shift*.</span>

<span class="sd">    .. rubric:: Theorical background</span>

<span class="sd">    First, the **doppler bandwidth** of the scattered signal due to the rotation of the object around its own</span>
<span class="sd">    orbit is calculated using the relation </span>

<span class="sd">    .. math::            B_{doppler} = \\frac{4 \\pi D}{\\lambda \\tau_s}</span>

<span class="sd">    with :math:`D` the diameter of the object, :math:`\\lambda` the wavelength of the radar signal and :math:`\\tau_s`</span>
<span class="sd">    the rotation period of the object around its own axis.</span>

<span class="sd">    The **measurement bandwidth** :math:`B_{m}` corresponds to the maximum bandwidth between the observation bandwidth </span>
<span class="sd">    :math:`B_{obs} = 1/ \\tau_{obs}`, the effective signal bandwidth :math:`B_{s} = \\beta_{rx} \\eta` (:math:`\\beta_{rx}`</span>
<span class="sd">    corresponds to the bandwidth of the receiver and :math:`\\eta` the transmitter duty cycle) and the Doppler bandwdth </span>
<span class="sd">    :math:`B_{doppler}`. On the other hand, the **incoherent integration** bandwidth math:`B_{inc}` corresponds to the maximum bandwidth</span>
<span class="sd">    between :math:`B_{doppler}` and :math:`B_{obs}`.</span>

<span class="sd">    After computing the *SNR* and the *receiver noise power* (see :ref:`signals-theory-snr`), it is then possible to </span>
<span class="sd">    compute the actual *signal power*. We can then compute the **coherent noise power**:</span>

<span class="sd">    .. math:: P_{N,coh} = \\frac{k_B T_{tx} B_m}{\\eta}</span>

<span class="sd">    and compute the **incoherent SNR** :math:`SNR_{coh} = P_s/P_{N,coh}`. Finally, the **incoherent noise power** can be expressed</span>
<span class="sd">    as:</span>

<span class="sd">    .. math:: P_{N,inc} = \\frac{k_B T_{tx} B_{inc}}{\\eta}</span>

<span class="sd">    From which we can deduce the **incoherent SNR**:</span>

<span class="sd">    .. math:: SNR_{inc} = \\frac{P_s}{P_{N,inc}} \\sqrt{B_{inc} \\tau_{obs}}</span>


<span class="sd">    .. rubric:: Syntax</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t_obs : float / numpy.ndarray</span>
<span class="sd">        Measurement duration (s)</span>
<span class="sd">    spin_period : float / numpy.ndarray</span>
<span class="sd">        Rotation period of the object being observed (s)</span>
<span class="sd">    gain_tx : float / numpy.ndarray</span>
<span class="sd">        Transmit antenna gain, linear (-)</span>
<span class="sd">    gain_rx : float / numpy.ndarray</span>
<span class="sd">        Receiver antenna gain, linear (-)</span>
<span class="sd">    wavelength : float / numpy.ndarray</span>
<span class="sd">        Radar wavelength (m)</span>
<span class="sd">    power_tx : float / numpy.ndarray</span>
<span class="sd">        Transmit power (W)</span>
<span class="sd">    range_tx_m : float / numpy.ndarray</span>
<span class="sd">        Range from transmitter to target (m)</span>
<span class="sd">    range_rx_m : float / numpy.ndarray</span>
<span class="sd">        Range from target to receiver (m)</span>
<span class="sd">    duty_cycle : float / numpy.ndarray</span>
<span class="sd">        RADAR measurement duty cycle (-)</span>
<span class="sd">    diameter : float / numpy.ndarray</span>
<span class="sd">        Object diameter (m)</span>
<span class="sd">    bandwidth : float / numpy.ndarray</span>
<span class="sd">        Effective receiver noise bandwidth (Hz)</span>
<span class="sd">    rx_noise_temp : float / numpy.ndarray</span>
<span class="sd">        Receiver noise temperature (K)</span>
<span class="sd">    radar_albedo : float / numpy.ndarray</span>
<span class="sd">        Radar albedo of the object beaing observed (-)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    snr_coh : float / numpy.ndarray</span>
<span class="sd">        Signal-to-Noise Ratio (SNR) using **coherent integration**, when doing object discovery with a limited </span>
<span class="sd">        coherent integration duration and no incoherent integration</span>

<span class="sd">    snr_incoh : float / numpy.ndarray</span>
<span class="sd">        Signal-to-Noise Ratio (SNR) using **incoherent integration**.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A simple example using the ``doppler_spread_hard_target_snr`` consists in calculating the **SNR** (coherent/incoherent) </span>
<span class="sd">    for a specific space object/radar arrangement. This SNR value can then be compated to a threshold value to determine </span>
<span class="sd">    if the space object would have been detected with the current system configuration.</span>

<span class="sd">    .. code-block:: Python</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        import sorts</span>

<span class="sd">        # intitializes the radar</span>
<span class="sd">        radar = sorts.radars.eiscat3d</span>

<span class="sd">        # point stations towards local vertical</span>
<span class="sd">        k0 = np.array([0,0,1])</span>
<span class="sd">        radar.tx[0].beam.point(k0)</span>
<span class="sd">        radar.rx[0].beam.point(k0)</span>

<span class="sd">        # compute incoherent and coherent SNR</span>
<span class="sd">        snr_coh, snr_incoh = sorts.signals.doppler_spread_hard_target_snr(</span>
<span class="sd">            3600.0, </span>
<span class="sd">            gain_tx = radar.tx[0].beam.gain(k0),</span>
<span class="sd">            gain_rx = radar.rx[0].beam.gain(k0),</span>
<span class="sd">            wavelength = radar.tx[0].wavelength,</span>
<span class="sd">            power_tx = radar.tx[0].power,</span>
<span class="sd">            range_tx_m = 300000e3, </span>
<span class="sd">            range_rx_m = 300000e3,</span>
<span class="sd">            duty_cycle=0.25,</span>
<span class="sd">            bandwidth=10,</span>
<span class="sd">            rx_noise_temp=150.0,</span>
<span class="sd">            diameter=150.0,</span>
<span class="sd">            spin_period=500.0,</span>
<span class="sd">            radar_albedo=0.1,</span>
<span class="sd">        )</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Radar observability of near-Earth objects with EISCAT 3D, D. Kastinen et. al., 2020</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># compute the bandwidth of the doppler shifted RADAR echo</span>
    <span class="n">doppler_bandwidth</span> <span class="o">=</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">diameter</span><span class="o">/</span><span class="p">(</span><span class="n">wavelength</span><span class="o">*</span><span class="n">spin_period</span><span class="p">)</span>
    
    <span class="c1"># measurement bandwidth (coherent integration)</span>
    <span class="n">measurement_bandwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">doppler_bandwidth</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">*</span><span class="n">duty_cycle</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">t_obs</span><span class="p">])</span> <span class="c1"># coherent : for serendipitous discovery</span>

    <span class="c1"># measurement bandwidth with incoherent integration, when a priori information about the target is available</span>
    <span class="n">base_int_bandwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">doppler_bandwidth</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">t_obs</span><span class="p">])</span>
    
    <span class="c1"># Compute signal properties</span>
    <span class="n">h_snr</span> <span class="o">=</span> <span class="n">hard_target_snr</span><span class="p">(</span>    <span class="c1"># compute standard hard target SNR</span>
        <span class="n">gain_tx</span> <span class="o">=</span> <span class="n">gain_tx</span><span class="p">,</span> 
        <span class="n">gain_rx</span> <span class="o">=</span> <span class="n">gain_rx</span><span class="p">,</span>
        <span class="n">wavelength</span> <span class="o">=</span> <span class="n">wavelength</span><span class="p">,</span>
        <span class="n">power_tx</span> <span class="o">=</span> <span class="n">power_tx</span><span class="p">,</span>
        <span class="n">range_tx_m</span> <span class="o">=</span> <span class="n">range_tx_m</span><span class="p">,</span> 
        <span class="n">range_rx_m</span> <span class="o">=</span> <span class="n">range_rx_m</span><span class="p">,</span>
        <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span><span class="p">,</span> 
        <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">bandwidth</span><span class="p">,</span>
        <span class="n">rx_noise_temp</span> <span class="o">=</span> <span class="n">rx_noise_temp</span><span class="p">,</span>
        <span class="n">radar_albedo</span> <span class="o">=</span> <span class="n">radar_albedo</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="n">rx_noise</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="n">rx_noise_temp</span> <span class="o">*</span> <span class="n">bandwidth</span> <span class="c1"># compute the noise measured by the receiver</span>
    <span class="n">signal_power</span> <span class="o">=</span> <span class="n">h_snr</span> <span class="o">*</span> <span class="n">rx_noise</span> <span class="c1"># compute the noised measured by the receiver</span>
    
    <span class="c1"># compute the SNR</span>
    <span class="c1"># coherent : effective noise power when using just coherent integration</span>
    <span class="n">coh_noise_power</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="n">rx_noise_temp</span> <span class="o">*</span> <span class="n">measurement_bandwidth</span><span class="o">/</span><span class="n">duty_cycle</span>
    <span class="n">snr_coh</span> <span class="o">=</span> <span class="n">signal_power</span><span class="o">/</span><span class="n">coh_noise_power</span>
    
    <span class="c1"># incoherent : effective noise power when doing incoherent integration and using a good a priori orbital elements</span>
    <span class="n">incoh_noise_power</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="n">rx_noise_temp</span> <span class="o">*</span> <span class="n">base_int_bandwidth</span><span class="o">/</span><span class="n">duty_cycle</span>

    <span class="n">snr</span><span class="p">,</span> <span class="n">snr_incoh</span><span class="p">,</span> <span class="n">te</span> <span class="o">=</span> <span class="n">incoherent_snr</span><span class="p">(</span><span class="n">signal_power</span><span class="p">,</span> <span class="n">incoh_noise_power</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="n">base_int_bandwidth</span><span class="p">,</span> <span class="n">incoherent_integration_time</span><span class="o">=</span><span class="n">t_obs</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">snr_coh</span><span class="p">,</span> <span class="n">snr_incoh</span></div>
</pre></div>

              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright [2020-2022] Daniel Kastinen, Juha Vierinen, Thomas Maynadie.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>