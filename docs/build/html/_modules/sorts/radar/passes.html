
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sorts.radar.passes &#8212; SORTS v4.0 Manual</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "dark";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="None">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="dark">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    <p class="title logo__title">SORTS v4.0 Manual</p>
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../intro.html">
  Introduction
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../install.html">
  Installation
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../usermanual.html">
  SORTS Manual
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/danielk333/sorts" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <h1>Source code for sorts.radar.passes</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;Encapsulates a fundamental component of tracking space objects: a </span>
<span class="sd">pass over a geographic location. Also provides convenience functions </span>
<span class="sd">for finding passes given states and stations and sorting structures </span>
<span class="sd">of passes in particular ways. </span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pyorb</span>
<span class="kn">import</span> <span class="nn">pyant</span>

<span class="kn">import</span> <span class="nn">multiprocessing</span>

<span class="c1">#Local import</span>
<span class="kn">from</span> <span class="nn">..transformations</span> <span class="kn">import</span> <span class="n">frames</span>
<span class="kn">from</span> <span class="nn">.signals</span> <span class="kn">import</span> <span class="n">hard_target_snr</span>

<div class="viewcode-block" id="Pass"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.html#sorts.radar.passes.Pass">[docs]</a><span class="k">class</span> <span class="nc">Pass</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    Encapsulates a space object *pass* over a geographical location. </span>

<span class="sd">    The :class:`Pass` contains all the functions and attributes needed to store</span>
<span class="sd">    and run computations over the sequence of states which belong to the pass.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : numpy.ndarray of float (N,)</span>
<span class="sd">        Time points associated with the space object&#39;s states (s). </span>
<span class="sd">    enu : numpy.ndarray of float (6, N)</span>
<span class="sd">        Space object&#39;s states in the station local *ENU* coordinate frame (m).</span>
<span class="sd">    inds : numpy.ndarray of int, default=None</span>
<span class="sd">        Indices of the space object&#39;s states within the larger state dataset.</span>
<span class="sd">    cache : bool, default=True</span>
<span class="sd">        If True, ``start``, ``end``, ``range``, ``range_rate`` and ``zenit_angle``</span>
<span class="sd">        will only be computed once and the result will be stored, therefore increasing</span>
<span class="sd">        RAM usage.</span>

<span class="sd">        If False, the computations of those attributes will be computed at each </span>
<span class="sd">        call, therefore increasing computation time.</span>
<span class="sd">    stations : list of :class:`sorts.Station&lt;sorts.radar.system.station.Station&gt;`, default=None</span>
<span class="sd">        Radar :class:`sorts.Stations&lt;sorts.radar.system.station.Station&gt;` associated with the radar</span>
<span class="sd">        pass. Usually, the :class:`Pass` is defined as the set of states within the </span>
<span class="sd">        combined FOV of :class:`sorts.Stations&lt;sorts.radar.system.station.Station&gt;` </span>
<span class="sd">        within ``stations``.  </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    As a simple example, consider an array ``states`` of space object&#39;s states propagated </span>
<span class="sd">    using a :ref:`propagator`.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; states.shape</span>
<span class="sd">    (6, 150)</span>
<span class="sd">    &gt;&gt;&gt; t_states.shape</span>
<span class="sd">    (150)</span>

<span class="sd">    The creation of a new :class:`Pass` object holding the first 10 states of the ``states`` </span>
<span class="sd">    array can be achieved by running:</span>

<span class="sd">    &gt;&gt;&gt; inds = np.arange(0, 9)</span>
<span class="sd">    &gt;&gt;&gt; pass1 = Pass(</span>
<span class="sd">    ...     t_states[inds], </span>
<span class="sd">    ...     radar.tx.enu(states[:, inds]), # convert states to ENU in the TX reference frame</span>
<span class="sd">    ...     inds,</span>
<span class="sd">    ...     cache=False,</span>
<span class="sd">    ...     stations=[radar.tx[0], radar.rx[0]])</span>

<span class="sd">    The new :class:`Pass` object will be associated with the 1st :ref:`station_tx` station and the first</span>
<span class="sd">    :ref:`station_rx` station of the radar system (see :ref:`radar` for more information about</span>
<span class="sd">    the creation of radar systems).</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Pass.__init__"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.__init__.html#sorts.radar.passes.Pass.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">enu</span><span class="p">,</span> <span class="n">inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Default :class:`Pass` class constructor. &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inds</span> <span class="o">=</span> <span class="n">inds</span>
        <span class="sd">&#39;&#39;&#39; Indices of space object&#39;s states constituing the :class:`Pass`. &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="sd">&#39;&#39;&#39; Time points associated with the space object&#39;s states (s). &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">enu</span> <span class="o">=</span> <span class="n">enu</span>
        <span class="sd">&#39;&#39;&#39; Space object&#39;s states in the station local *ENU* coordinate frame (m). &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span>
        <span class="sd">&#39;&#39;&#39; If True, the results of ``start``, ``end``, ``range``, ``range_rate`` and </span>
<span class="sd">        ``zenit_angle`` will be cached. &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_stations</span> <span class="o">=</span> <span class="n">stations</span>
        <span class="sd">&#39;&#39;&#39; Radar :ref:`station` associated with the :class:`Pass` &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">snr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&#39;&#39;&#39; Optimal Signal-to-Noise Ratio (SNR) computed from the states constituing </span>
<span class="sd">        the :class:`Pass`. &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&#39;&#39;&#39; Start time of the :class:`Pass` &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&#39;&#39;&#39; End time of the :class:`Pass` &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_range</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&#39;&#39;&#39; Object *range* from the stations at each time point. &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_range_rate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&#39;&#39;&#39; Object *range rate* from the stations at each time point. &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_zenith_angle</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&#39;&#39;&#39; Object *zenith angle* with respect to the stations at each time point. &#39;&#39;&#39;</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Implementation of __str__. &#39;&#39;&#39;</span>
        <span class="n">str_</span> <span class="o">=</span> <span class="s1">&#39;Pass &#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">str_</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;Station </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_stations</span><span class="si">}</span><span class="s1"> | &#39;</span>
        <span class="n">str_</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;Rise </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()))</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">())</span><span class="o">/</span><span class="mf">60.0</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1"> min) </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">()))</span><span class="si">}</span><span class="s1"> Fall&#39;</span>
        
        <span class="k">return</span> <span class="n">str_</span>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Implementation of __repr__. &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="Pass.calculate_snr"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.calculate_snr.html#sorts.radar.passes.Pass.calculate_snr">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_snr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">tx</span><span class="p">,</span> 
        <span class="n">rx</span><span class="p">,</span>
        <span class="n">diameter</span><span class="p">,</span>
        <span class="n">parallelization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">n_processes</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Uses the :code:`signals.hard_target_snr` function to calculate the optimal </span>
<span class="sd">        SNR curve of a target during the pass.</span>
<span class="sd">    </span>
<span class="sd">        The **optimal SNR** curve corresponds to the SNR measured when the object</span>
<span class="sd">        is exactly in the line-of-sight of the radar (i.e. the gain is maximum). </span>
<span class="sd">        The SNR&#39;s are returned from the function but also stored in the property </span>
<span class="sd">        :code:`self.snr`. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tx : :class:`TX&lt;sorts.radar.system.station.TX&gt;` </span>
<span class="sd">            :class:`TX&lt;sorts.radar.system.station.TX&gt;` station observing the pass.</span>
<span class="sd">        rx : :class:`RX&lt;sorts.radar.system.station.RX&gt;`</span>
<span class="sd">            :class:`RX&lt;sorts.radar.system.station.RX&gt;` station observing the pass.</span>
<span class="sd">        diameter : float</span>
<span class="sd">            Space object diameter (m).</span>
<span class="sd">        parallelization : bool, default=True</span>
<span class="sd">            If ``True``, the computations will be run using the ``multiprocessing`` </span>
<span class="sd">            capabilities of python.</span>
<span class="sd">        n_processes : int, default=16</span>
<span class="sd">            Number of parallel processes during computations (only used when </span>
<span class="sd">            ``parallelization`` is ``True``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarrat of float (N,) </span>
<span class="sd">            Vector of optimal SNR values measured by the receiver during the pass.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider a space object (Kepler propagator) passing over the **EISCAT_3D** radar system:</span>

<span class="sd">        &gt;&gt;&gt; import sorts</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; radar = sorts.radars.eiscat3d</span>
<span class="sd">        &gt;&gt;&gt; Prop_cls = sorts.propagator.Kepler</span>
<span class="sd">        &gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">        ...     settings = dict(</span>
<span class="sd">        ...         out_frame=&#39;ITRS&#39;,</span>
<span class="sd">        ...         in_frame=&#39;TEME&#39;,</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Object</span>
<span class="sd">        &gt;&gt;&gt; space_object = sorts.SpaceObject(</span>
<span class="sd">        ...         Prop_cls,</span>
<span class="sd">        ...         propagator_options = Prop_opts,</span>
<span class="sd">        ...         a = 7000e3, </span>
<span class="sd">        ...         e = 0.0,</span>
<span class="sd">        ...         i = 78,</span>
<span class="sd">        ...         raan = 86,</span>
<span class="sd">        ...         aop = 0, </span>
<span class="sd">        ...         mu0 = 50,</span>
<span class="sd">        ...         epoch = 53005.0,</span>
<span class="sd">        ...         parameters = dict(</span>
<span class="sd">        ...             d = 0.1,</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; print(space_object)</span>
<span class="sd">        Space object 1: &lt;Time object: scale=&#39;utc&#39; format=&#39;mjd&#39; value=53005.0&gt;:</span>
<span class="sd">        a    : 7.0000e+06   x : -7.9830e+05</span>
<span class="sd">        e    : 0.0000e+00   y : 4.5663e+06</span>
<span class="sd">        i    : 7.8000e+01   z : 5.2451e+06</span>
<span class="sd">        omega: 0.0000e+00   vx: -1.4093e+03</span>
<span class="sd">        Omega: 8.6000e+01   vy: -5.6962e+03</span>
<span class="sd">        anom : 5.0000e+01   vz: 4.7445e+03</span>
<span class="sd">        Parameters: C_D=2.3, m=1.0, C_R=1.0, d=0.1</span>
<span class="sd">    </span>
<span class="sd">        The states are propagated over a time period of 1 day:</span>

<span class="sd">        &gt;&gt;&gt; t_states = sorts.equidistant_sampling(</span>
<span class="sd">        ...     orbit=space_object.state, </span>
<span class="sd">        ...     start_t=0, </span>
<span class="sd">        ...     end_t=3600.0, </span>
<span class="sd">        ...     max_dpos=10e3)</span>
<span class="sd">        &gt;&gt;&gt; object_states = space_object.get_state(t_states)</span>

<span class="sd">        The passes can then be found in the state array as follows:</span>

<span class="sd">        &gt;&gt;&gt; radar_passes = radar.find_passes(t_states, object_states, cache_data=True) </span>
<span class="sd">        &gt;&gt;&gt; radar_passes </span>
<span class="sd">        [[[Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, </span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7f1f904860c0&gt;] | Rise 0:04:05.161251 (4.4 min) 0:08:30.200441 Fall], </span>
<span class="sd">        [Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object </span>
<span class="sd">        at 0x7f1f903ca340&gt;] | Rise 0:04:05.161251 (4.3 min) 0:08:23.574462 Fall], [Pass Station [&lt;sorts.radar.system.</span>
<span class="sd">        station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object at 0x7f1f903eebc0&gt;] | Rise 0:04:05.</span>
<span class="sd">        161251 (4.1 min) 0:08:10.322502 Fall]]]</span>

<span class="sd">        To compute the SNR over all the :class:`RX&lt;sorts.radar.system.station.RX&gt;` stations, run:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; snr = np.ndarray((len(radar.rx),), dtype=object)</span>
<span class="sd">        &gt;&gt;&gt; for rxi in range(len(radar.rx)):</span>
<span class="sd">        ...     snr[rxi] = radar_passes[0][rxi][0].calculate_snr(radar.tx[0], radar.rx[rxi], 0.1, parallelization=True, n_processes=16)</span>
<span class="sd">        </span>
<span class="sd">        Finally, the results can be plotted as follow:</span>

<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(111)</span>
<span class="sd">        &gt;&gt;&gt; fmt = [&quot;-r&quot;, &quot;-g&quot;, &quot;-b&quot;]</span>
<span class="sd">        &gt;&gt;&gt; for rxi in range(len(radar.rx)):</span>
<span class="sd">        ...     ax.plot(t_states[radar_passes[0][rxi][0].inds], 10*np.log10(snr[rxi]), fmt[rxi], label=f&quot;Rx {rxi}&quot;) </span>
<span class="sd">        &gt;&gt;&gt; ax.set_xlabel(&quot;$t$ [$s$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_ylabel(&quot;$SNR$ [$-$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.grid()</span>
<span class="sd">        &gt;&gt;&gt; ax.legend()</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">        Yiedlding: </span>

<span class="sd">        .. figure:: ../../../../figures/passes_example_snr.png</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;SNR can only be computed for TX-RX pairs&quot;</span><span class="p">)</span>

        <span class="c1"># compute the number of states being handled by each process</span>
        <span class="n">n_time_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="n">n_max_points_per_period</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_time_points</span><span class="o">/</span><span class="p">(</span><span class="n">n_processes</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">n_max_points_per_period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n_processes</span> <span class="o">=</span> <span class="n">n_time_points</span>
            <span class="n">n_max_points_per_period</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">n_points_last_period</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_points_last_period</span> <span class="o">=</span> <span class="n">n_time_points</span><span class="o">%</span><span class="p">((</span><span class="n">n_processes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n_max_points_per_period</span><span class="p">)</span>

        <span class="c1"># compute range and enu states</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">()</span>
        <span class="n">enus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enu</span>

        <span class="c1"># intialization of the SNR array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_time_points</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">process_function</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">n_points</span><span class="p">,</span> <span class="n">return_dict</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39; Multiprocessing function. &#39;&#39;&#39;</span>
            <span class="c1"># compute gain</span>
            <span class="c1"># TODO change implementation when pyant has a vectorized compute gain method</span>
            <span class="n">tx_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_points</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">rx_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_points</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
                <span class="n">ti</span> <span class="o">=</span> <span class="n">n_max_points_per_period</span><span class="o">*</span><span class="n">pid</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">tx</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">enus</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">3</span><span class="p">,</span><span class="n">ti</span><span class="p">])</span>
                <span class="n">rx</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">enus</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">3</span><span class="p">,</span><span class="n">ti</span><span class="p">])</span>

                <span class="n">tx_gain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">gain</span><span class="p">(</span><span class="n">enus</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">3</span><span class="p">,</span><span class="n">ti</span><span class="p">])</span>
                <span class="n">rx_gain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">gain</span><span class="p">(</span><span class="n">enus</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">3</span><span class="p">,</span><span class="n">ti</span><span class="p">])</span>

            <span class="c1"># compute snr</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">hard_target_snr</span><span class="p">(</span>
                <span class="n">tx_gain</span><span class="p">,</span>
                <span class="n">rx_gain</span><span class="p">,</span>
                <span class="n">rx</span><span class="o">.</span><span class="n">wavelength</span><span class="p">,</span>
                <span class="n">tx</span><span class="o">.</span><span class="n">power</span><span class="p">,</span>
                <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n_max_points_per_period</span><span class="o">*</span><span class="n">pid</span><span class="p">:</span><span class="n">n_max_points_per_period</span><span class="o">*</span><span class="n">pid</span> <span class="o">+</span> <span class="n">n_points</span><span class="p">],</span>
                <span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n_max_points_per_period</span><span class="o">*</span><span class="n">pid</span><span class="p">:</span><span class="n">n_max_points_per_period</span><span class="o">*</span><span class="n">pid</span> <span class="o">+</span> <span class="n">n_points</span><span class="p">],</span>
                <span class="n">diameter</span><span class="o">=</span><span class="n">diameter</span><span class="p">,</span>
                <span class="n">bandwidth</span><span class="o">=</span><span class="n">tx</span><span class="o">.</span><span class="n">coh_int_bandwidth</span><span class="p">,</span>
                <span class="n">rx_noise_temp</span><span class="o">=</span><span class="n">rx</span><span class="o">.</span><span class="n">noise_temperature</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># multiprocessing manager</span>
        <span class="n">manager</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span>
        <span class="n">process_subgroup</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># set up and run computations</span>
        <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_processes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pid</span> <span class="o">&lt;</span> <span class="n">n_processes</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">n_points</span> <span class="o">=</span> <span class="n">n_max_points_per_period</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_points</span> <span class="o">=</span> <span class="n">n_points_last_period</span>

            <span class="k">if</span> <span class="n">parallelization</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># create new process</span>
                <span class="n">process</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">process_function</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">n_points</span><span class="p">,</span> <span class="n">return_dict</span><span class="p">))</span> 
                <span class="n">process_subgroup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
                <span class="n">process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">snr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">process_function</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">n_points</span><span class="p">,</span> <span class="n">snr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="p">[</span><span class="n">n_max_points_per_period</span><span class="o">*</span><span class="n">pid</span><span class="p">:</span><span class="n">n_max_points_per_period</span><span class="o">*</span><span class="n">pid</span> <span class="o">+</span> <span class="n">n_points</span><span class="p">]</span> <span class="o">=</span> <span class="n">snr</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span>

        <span class="c1"># retreive computation results</span>
        <span class="k">if</span> <span class="n">parallelization</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_processes</span><span class="p">):</span>
                <span class="n">process_subgroup</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

            <span class="n">id_start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_processes</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">return_dict</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span>
                <span class="n">id_end</span> <span class="o">=</span> <span class="n">id_start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="p">[</span><span class="n">id_start</span><span class="p">:</span><span class="n">id_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                <span class="n">id_start</span> <span class="o">=</span> <span class="n">id_end</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns the number of stations that can observe the pass. &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stations</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stations</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stations</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>


<div class="viewcode-block" id="Pass.start"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.start.html#sorts.radar.passes.Pass.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns the start time of the pass (uses cached value after first call if :code:`self.cache=True`). &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>


<div class="viewcode-block" id="Pass.end"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.end.html#sorts.radar.passes.Pass.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns the ending time of the pass (uses cached value after first call if :code:`self.cache=True`). &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">()</span></div>


<div class="viewcode-block" id="Pass.calculate_range"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.calculate_range.html#sorts.radar.passes.Pass.calculate_range">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_range</span><span class="p">(</span><span class="n">enu</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns the ``ranges`` associated with a set of *ENU* states.</span>

<span class="sd">        The computation of the range relies on the computation of the norm of the </span>
<span class="sd">        ``Pass.enu`` states. Therefore, the results will correspond to the consecutive</span>
<span class="sd">        ranges between the space object and the reference station in which frame the</span>
<span class="sd">        states are defined. </span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        enu : numpy.ndarray (6, N)</span>
<span class="sd">            Space object&#39;s states in the *ENU* frame of the reference station.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ranges : numpy.ndarray</span>
<span class="sd">            Ranges of the object at each time point.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider a space object (Kepler propagator) passing over the **EISCAT_3D** radar system:</span>

<span class="sd">        &gt;&gt;&gt; import sorts</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; radar = sorts.radars.eiscat3d</span>
<span class="sd">        &gt;&gt;&gt; Prop_cls = sorts.propagator.Kepler</span>
<span class="sd">        &gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">        ...     settings = dict(</span>
<span class="sd">        ...         out_frame=&#39;ITRS&#39;,</span>
<span class="sd">        ...         in_frame=&#39;TEME&#39;,</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Object</span>
<span class="sd">        &gt;&gt;&gt; space_object = sorts.SpaceObject(</span>
<span class="sd">        ...         Prop_cls,</span>
<span class="sd">        ...         propagator_options = Prop_opts,</span>
<span class="sd">        ...         a = 7000e3, </span>
<span class="sd">        ...         e = 0.0,</span>
<span class="sd">        ...         i = 78,</span>
<span class="sd">        ...         raan = 86,</span>
<span class="sd">        ...         aop = 0, </span>
<span class="sd">        ...         mu0 = 50,</span>
<span class="sd">        ...         epoch = 53005.0,</span>
<span class="sd">        ...         parameters = dict(</span>
<span class="sd">        ...             d = 0.1,</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; print(space_object)</span>
<span class="sd">        Space object 1: &lt;Time object: scale=&#39;utc&#39; format=&#39;mjd&#39; value=53005.0&gt;:</span>
<span class="sd">        a    : 7.0000e+06   x : -7.9830e+05</span>
<span class="sd">        e    : 0.0000e+00   y : 4.5663e+06</span>
<span class="sd">        i    : 7.8000e+01   z : 5.2451e+06</span>
<span class="sd">        omega: 0.0000e+00   vx: -1.4093e+03</span>
<span class="sd">        Omega: 8.6000e+01   vy: -5.6962e+03</span>
<span class="sd">        anom : 5.0000e+01   vz: 4.7445e+03</span>
<span class="sd">        Parameters: C_D=2.3, m=1.0, C_R=1.0, d=0.1</span>
<span class="sd">    </span>
<span class="sd">        The states are propagated over a time period of 1 day:</span>

<span class="sd">        &gt;&gt;&gt; t_states = sorts.equidistant_sampling(</span>
<span class="sd">        ...     orbit=space_object.state, </span>
<span class="sd">        ...     start_t=0, </span>
<span class="sd">        ...     end_t=3600.0, </span>
<span class="sd">        ...     max_dpos=10e3)</span>
<span class="sd">        &gt;&gt;&gt; object_states = space_object.get_state(t_states)</span>

<span class="sd">        The passes can then be found in the state array as follows:</span>

<span class="sd">        &gt;&gt;&gt; radar_passes = radar.find_passes(t_states, object_states, cache_data=True) </span>
<span class="sd">        &gt;&gt;&gt; radar_passes </span>
<span class="sd">        [[[Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, </span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7f1f904860c0&gt;] | Rise 0:04:05.161251 (4.4 min) 0:08:30.200441 Fall], </span>
<span class="sd">        [Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object </span>
<span class="sd">        at 0x7f1f903ca340&gt;] | Rise 0:04:05.161251 (4.3 min) 0:08:23.574462 Fall], [Pass Station [&lt;sorts.radar.system.</span>
<span class="sd">        station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object at 0x7f1f903eebc0&gt;] | Rise 0:04:05.</span>
<span class="sd">        161251 (4.1 min) 0:08:10.322502 Fall]]]</span>

<span class="sd">        To compute and plot the range over all the :class:`RX&lt;sorts.radar.system.station.RX&gt;` stations, run:</span>

<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(111)</span>
<span class="sd">        &gt;&gt;&gt; fmt = [&quot;-r&quot;, &quot;-g&quot;, &quot;-b&quot;]</span>
<span class="sd">        &gt;&gt;&gt; for rxi in range(len(radar.rx)):</span>
<span class="sd">        ...     enu = radar.rx[rxi].enu(object_states[:, radar_passes[0][rxi][0].inds])</span>
<span class="sd">        ...     range_ = radar_passes[0][rxi][0].calculate_range(enu)</span>
<span class="sd">        ...     ax.plot(t_states[radar_passes[0][rxi][0].inds], range_, fmt[rxi], label=f&quot;Rx {rxi}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_xlabel(&quot;$t$ [$s$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_ylabel(&quot;$R_{rx}$ [$m$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.grid()</span>
<span class="sd">        &gt;&gt;&gt; ax.legend()</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">        Yiedlding: </span>

<span class="sd">        .. figure:: ../../../../figures/passes_example_range.png</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">enu</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="Pass.calculate_range_rate"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.calculate_range_rate.html#sorts.radar.passes.Pass.calculate_range_rate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_range_rate</span><span class="p">(</span><span class="n">enu</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns the ``range-rates`` associated with a set of *ENU* states.</span>
<span class="sd">        </span>
<span class="sd">        The *range-rate* corresponds to the projection of the velocity vector in the ENU</span>
<span class="sd">        frame of reference along the range vector (pointing from the *station* to the *object*).</span>

<span class="sd">        Therefore, the range-rate will be negative if the object is getting closer to the station </span>
<span class="sd">        and positive otherwise.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        enu : numpy.ndarray (6, N)</span>
<span class="sd">            Space object&#39;s states in the *ENU* frame of the reference station.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        range_rates : numpy.ndarray</span>
<span class="sd">            Range-rates of the object at each time point.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider a space object (Kepler propagator) passing over the **EISCAT_3D** radar system:</span>

<span class="sd">        &gt;&gt;&gt; import sorts</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; radar = sorts.radars.eiscat3d</span>
<span class="sd">        &gt;&gt;&gt; Prop_cls = sorts.propagator.Kepler</span>
<span class="sd">        &gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">        ...     settings = dict(</span>
<span class="sd">        ...         out_frame=&#39;ITRS&#39;,</span>
<span class="sd">        ...         in_frame=&#39;TEME&#39;,</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Object</span>
<span class="sd">        &gt;&gt;&gt; space_object = sorts.SpaceObject(</span>
<span class="sd">        ...         Prop_cls,</span>
<span class="sd">        ...         propagator_options = Prop_opts,</span>
<span class="sd">        ...         a = 7000e3, </span>
<span class="sd">        ...         e = 0.0,</span>
<span class="sd">        ...         i = 78,</span>
<span class="sd">        ...         raan = 86,</span>
<span class="sd">        ...         aop = 0, </span>
<span class="sd">        ...         mu0 = 50,</span>
<span class="sd">        ...         epoch = 53005.0,</span>
<span class="sd">        ...         parameters = dict(</span>
<span class="sd">        ...             d = 0.1,</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; print(space_object)</span>
<span class="sd">        Space object 1: &lt;Time object: scale=&#39;utc&#39; format=&#39;mjd&#39; value=53005.0&gt;:</span>
<span class="sd">        a    : 7.0000e+06   x : -7.9830e+05</span>
<span class="sd">        e    : 0.0000e+00   y : 4.5663e+06</span>
<span class="sd">        i    : 7.8000e+01   z : 5.2451e+06</span>
<span class="sd">        omega: 0.0000e+00   vx: -1.4093e+03</span>
<span class="sd">        Omega: 8.6000e+01   vy: -5.6962e+03</span>
<span class="sd">        anom : 5.0000e+01   vz: 4.7445e+03</span>
<span class="sd">        Parameters: C_D=2.3, m=1.0, C_R=1.0, d=0.1</span>
<span class="sd">    </span>
<span class="sd">        The states are propagated over a time period of 1 day:</span>

<span class="sd">        &gt;&gt;&gt; t_states = sorts.equidistant_sampling(</span>
<span class="sd">        ...     orbit=space_object.state, </span>
<span class="sd">        ...     start_t=0, </span>
<span class="sd">        ...     end_t=3600.0, </span>
<span class="sd">        ...     max_dpos=10e3)</span>
<span class="sd">        &gt;&gt;&gt; object_states = space_object.get_state(t_states)</span>

<span class="sd">        The passes can then be found in the state array as follows:</span>

<span class="sd">        &gt;&gt;&gt; radar_passes = radar.find_passes(t_states, object_states, cache_data=True) </span>
<span class="sd">        &gt;&gt;&gt; radar_passes </span>
<span class="sd">        [[[Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, </span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7f1f904860c0&gt;] | Rise 0:04:05.161251 (4.4 min) 0:08:30.200441 Fall], </span>
<span class="sd">        [Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object </span>
<span class="sd">        at 0x7f1f903ca340&gt;] | Rise 0:04:05.161251 (4.3 min) 0:08:23.574462 Fall], [Pass Station [&lt;sorts.radar.system.</span>
<span class="sd">        station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object at 0x7f1f903eebc0&gt;] | Rise 0:04:05.</span>
<span class="sd">        161251 (4.1 min) 0:08:10.322502 Fall]]]</span>

<span class="sd">        To compute and plot the *range rate* over all the :class:`RX&lt;sorts.radar.system.station.RX&gt;` stations, run:</span>

<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(111)</span>
<span class="sd">        &gt;&gt;&gt; fmt = [&quot;-r&quot;, &quot;-g&quot;, &quot;-b&quot;]</span>
<span class="sd">        &gt;&gt;&gt; for rxi in range(len(radar.rx)):</span>
<span class="sd">        ...     enu = radar.rx[rxi].enu(object_states[:, radar_passes[0][rxi][0].inds])</span>
<span class="sd">        ...     range_rate = radar_passes[0][rxi][0].calculate_range_rate(enu)</span>
<span class="sd">        ...     ax.plot(t_states[radar_passes[0][rxi][0].inds], range_rate, fmt[rxi], label=f&quot;Rx {rxi}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_xlabel(&quot;$t$ [$s$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_ylabel(&quot;$v_r_{rx}$ [$m/s$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.grid()</span>
<span class="sd">        &gt;&gt;&gt; ax.legend()</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">        Yiedlding: </span>

<span class="sd">        .. figure:: ../../../../figures/passes_example_range_rate.png</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">enu</span><span class="p">[</span><span class="mi">3</span><span class="p">:,:]</span><span class="o">*</span><span class="p">(</span><span class="n">enu</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">enu</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="Pass.calculate_zenith_angle"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.calculate_zenith_angle.html#sorts.radar.passes.Pass.calculate_zenith_angle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_zenith_angle</span><span class="p">(</span><span class="n">enu</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns the ``zenith angle`` of all the states within the :class:`Pass`.</span>
<span class="sd">        </span>
<span class="sd">        The *zenith angle* corresponds to angle between the local vertical of the reference</span>
<span class="sd">        station and the position vector (pointing from the *station* to the *object*).</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        enu : numpy.ndarray (6, N)</span>
<span class="sd">            Space object&#39;s states in the *ENU* frame of the reference station.</span>
<span class="sd">        radians : bool, default=False</span>
<span class="sd">            If ``True``, the angles will be expressed in rafians. If not, all the</span>
<span class="sd">            angles will be in degrees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        zenith_angle : numpy.ndarray</span>
<span class="sd">            Zenith angles of the object at each time point.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider a space object (Kepler propagator) passing over the **EISCAT_3D** radar system:</span>

<span class="sd">        &gt;&gt;&gt; import sorts</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; radar = sorts.radars.eiscat3d</span>
<span class="sd">        &gt;&gt;&gt; Prop_cls = sorts.propagator.Kepler</span>
<span class="sd">        &gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">        ...     settings = dict(</span>
<span class="sd">        ...         out_frame=&#39;ITRS&#39;,</span>
<span class="sd">        ...         in_frame=&#39;TEME&#39;,</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Object</span>
<span class="sd">        &gt;&gt;&gt; space_object = sorts.SpaceObject(</span>
<span class="sd">        ...         Prop_cls,</span>
<span class="sd">        ...         propagator_options = Prop_opts,</span>
<span class="sd">        ...         a = 7000e3, </span>
<span class="sd">        ...         e = 0.0,</span>
<span class="sd">        ...         i = 78,</span>
<span class="sd">        ...         raan = 86,</span>
<span class="sd">        ...         aop = 0, </span>
<span class="sd">        ...         mu0 = 50,</span>
<span class="sd">        ...         epoch = 53005.0,</span>
<span class="sd">        ...         parameters = dict(</span>
<span class="sd">        ...             d = 0.1,</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; print(space_object)</span>
<span class="sd">        Space object 1: &lt;Time object: scale=&#39;utc&#39; format=&#39;mjd&#39; value=53005.0&gt;:</span>
<span class="sd">        a    : 7.0000e+06   x : -7.9830e+05</span>
<span class="sd">        e    : 0.0000e+00   y : 4.5663e+06</span>
<span class="sd">        i    : 7.8000e+01   z : 5.2451e+06</span>
<span class="sd">        omega: 0.0000e+00   vx: -1.4093e+03</span>
<span class="sd">        Omega: 8.6000e+01   vy: -5.6962e+03</span>
<span class="sd">        anom : 5.0000e+01   vz: 4.7445e+03</span>
<span class="sd">        Parameters: C_D=2.3, m=1.0, C_R=1.0, d=0.1</span>
<span class="sd">    </span>
<span class="sd">        The states are propagated over a time period of 1 day:</span>

<span class="sd">        &gt;&gt;&gt; t_states = sorts.equidistant_sampling(</span>
<span class="sd">        ...     orbit=space_object.state, </span>
<span class="sd">        ...     start_t=0, </span>
<span class="sd">        ...     end_t=3600.0, </span>
<span class="sd">        ...     max_dpos=10e3)</span>
<span class="sd">        &gt;&gt;&gt; object_states = space_object.get_state(t_states)</span>

<span class="sd">        The passes can then be found in the state array as follows:</span>

<span class="sd">        &gt;&gt;&gt; radar_passes = radar.find_passes(t_states, object_states, cache_data=True) </span>
<span class="sd">        &gt;&gt;&gt; radar_passes </span>
<span class="sd">        [[[Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, </span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7f1f904860c0&gt;] | Rise 0:04:05.161251 (4.4 min) 0:08:30.200441 Fall], </span>
<span class="sd">        [Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object </span>
<span class="sd">        at 0x7f1f903ca340&gt;] | Rise 0:04:05.161251 (4.3 min) 0:08:23.574462 Fall], [Pass Station [&lt;sorts.radar.system.</span>
<span class="sd">        station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object at 0x7f1f903eebc0&gt;] | Rise 0:04:05.</span>
<span class="sd">        161251 (4.1 min) 0:08:10.322502 Fall]]]</span>

<span class="sd">        To compute and plot the *zenith angle* over all the :class:`RX&lt;sorts.radar.system.station.RX&gt;` stations, run:</span>

<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(111)</span>
<span class="sd">        &gt;&gt;&gt; fmt = [&quot;-r&quot;, &quot;-g&quot;, &quot;-b&quot;]</span>
<span class="sd">        &gt;&gt;&gt; for rxi in range(len(radar.rx)):</span>
<span class="sd">        ...     enu = radar.rx[rxi].enu(object_states[:, radar_passes[0][rxi][0].inds])</span>
<span class="sd">        ...     zenith_angle = radar_passes[0][rxi][0].calculate_zenith_angle(enu)</span>
<span class="sd">        ...     ax.plot(t_states[radar_passes[0][rxi][0].inds], zenith_angle, fmt[rxi], label=f&quot;Rx {rxi}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_xlabel(&quot;$t$ [$s$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_ylabel(&quot;$\\theta_{rx}$ [$deg$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.grid()</span>
<span class="sd">        &gt;&gt;&gt; ax.legend()</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">        Yiedlding: </span>

<span class="sd">        .. figure:: ../../../../figures/passes_example_zenith_angle.png</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">pyant</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">vector_angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">enu</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:],</span> <span class="n">radians</span><span class="o">=</span><span class="n">radians</span><span class="p">)</span></div>


<div class="viewcode-block" id="Pass.get_range"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.get_range.html#sorts.radar.passes.Pass.get_range">[docs]</a>    <span class="k">def</span> <span class="nf">get_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns the ``ranges`` associated with a set of *ENU* states.</span>

<span class="sd">        The computation of the range relies on the computation of the norm of the </span>
<span class="sd">        ``Pass.enu`` states. Therefore, the results will correspond to the consecutive</span>
<span class="sd">        ranges between the space object and the reference station in which frame the</span>
<span class="sd">        states are defined. </span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ranges : numpy.ndarray</span>
<span class="sd">            Ranges of the object at each time point.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        See :attr:`Pass.range` to get a example.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Pass</span><span class="o">.</span><span class="n">calculate_range</span><span class="p">(</span><span class="n">enu</span><span class="p">)</span> <span class="k">for</span> <span class="n">enu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">enu</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Pass</span><span class="o">.</span><span class="n">calculate_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">enu</span><span class="p">)</span></div>


<div class="viewcode-block" id="Pass.range"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.range.html#sorts.radar.passes.Pass.range">[docs]</a>    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns the ``ranges`` of all the states within the :class:`Pass`.</span>

<span class="sd">        The computation of the range relies on the computation of the norm of the </span>
<span class="sd">        ``Pass.enu`` states. Therefore, the results will correspond to the consecutive</span>
<span class="sd">        ranges between the space object and the reference station in which frame the</span>
<span class="sd">        states are defined. </span>

<span class="sd">        .. note::</span>
<span class="sd">            if :attr:`Pass.cache` is True, *range* will only be computed once on the</span>
<span class="sd">            first call of the function. Any future call will return the cached values.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ranges : numpy.ndarray</span>
<span class="sd">            Ranges of the object at each time point.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider a space object (Kepler propagator) passing over the **EISCAT_3D** radar system:</span>

<span class="sd">        &gt;&gt;&gt; import sorts</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; radar = sorts.radars.eiscat3d</span>
<span class="sd">        &gt;&gt;&gt; Prop_cls = sorts.propagator.Kepler</span>
<span class="sd">        &gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">        ...     settings = dict(</span>
<span class="sd">        ...         out_frame=&#39;ITRS&#39;,</span>
<span class="sd">        ...         in_frame=&#39;TEME&#39;,</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Object</span>
<span class="sd">        &gt;&gt;&gt; space_object = sorts.SpaceObject(</span>
<span class="sd">        ...         Prop_cls,</span>
<span class="sd">        ...         propagator_options = Prop_opts,</span>
<span class="sd">        ...         a = 7000e3, </span>
<span class="sd">        ...         e = 0.0,</span>
<span class="sd">        ...         i = 78,</span>
<span class="sd">        ...         raan = 86,</span>
<span class="sd">        ...         aop = 0, </span>
<span class="sd">        ...         mu0 = 50,</span>
<span class="sd">        ...         epoch = 53005.0,</span>
<span class="sd">        ...         parameters = dict(</span>
<span class="sd">        ...             d = 0.1,</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; print(space_object)</span>
<span class="sd">        Space object 1: &lt;Time object: scale=&#39;utc&#39; format=&#39;mjd&#39; value=53005.0&gt;:</span>
<span class="sd">        a    : 7.0000e+06   x : -7.9830e+05</span>
<span class="sd">        e    : 0.0000e+00   y : 4.5663e+06</span>
<span class="sd">        i    : 7.8000e+01   z : 5.2451e+06</span>
<span class="sd">        omega: 0.0000e+00   vx: -1.4093e+03</span>
<span class="sd">        Omega: 8.6000e+01   vy: -5.6962e+03</span>
<span class="sd">        anom : 5.0000e+01   vz: 4.7445e+03</span>
<span class="sd">        Parameters: C_D=2.3, m=1.0, C_R=1.0, d=0.1</span>
<span class="sd">    </span>
<span class="sd">        The states are propagated over a time period of 1 day:</span>

<span class="sd">        &gt;&gt;&gt; t_states = sorts.equidistant_sampling(</span>
<span class="sd">        ...     orbit=space_object.state, </span>
<span class="sd">        ...     start_t=0, </span>
<span class="sd">        ...     end_t=3600.0, </span>
<span class="sd">        ...     max_dpos=10e3)</span>
<span class="sd">        &gt;&gt;&gt; object_states = space_object.get_state(t_states)</span>

<span class="sd">        The passes can then be found in the state array as follows:</span>

<span class="sd">        &gt;&gt;&gt; radar_passes = radar.find_passes(t_states, object_states, cache_data=True) </span>
<span class="sd">        &gt;&gt;&gt; radar_passes </span>
<span class="sd">        [[[Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, </span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7f1f904860c0&gt;] | Rise 0:04:05.161251 (4.4 min) 0:08:30.200441 Fall], </span>
<span class="sd">        [Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object </span>
<span class="sd">        at 0x7f1f903ca340&gt;] | Rise 0:04:05.161251 (4.3 min) 0:08:23.574462 Fall], [Pass Station [&lt;sorts.radar.system.</span>
<span class="sd">        station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object at 0x7f1f903eebc0&gt;] | Rise 0:04:05.</span>
<span class="sd">        161251 (4.1 min) 0:08:10.322502 Fall]]]</span>

<span class="sd">        To compute and plot the range over all the :class:`RX&lt;sorts.radar.system.station.RX&gt;` stations, run:</span>

<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(111)</span>
<span class="sd">        &gt;&gt;&gt; fmt = [&quot;-r&quot;, &quot;-g&quot;, &quot;-b&quot;]</span>
<span class="sd">        &gt;&gt;&gt; for rxi in range(len(radar.rx)):</span>
<span class="sd">        ...     ax.plot(t_states[radar_passes[0][rxi][0].inds], radar_passes[0][rxi][0].range()[1], fmt[rxi], label=f&quot;Rx {rxi}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_xlabel(&quot;$t$ [$s$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_ylabel(&quot;$R_{rx}$ [$m$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.grid()</span>
<span class="sd">        &gt;&gt;&gt; ax.legend()</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">        Yiedlding: </span>

<span class="sd">        .. figure:: ../../../../figures/passes_example_range.png</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_range</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_range</span><span class="p">()</span></div>


<div class="viewcode-block" id="Pass.get_range_rate"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.get_range_rate.html#sorts.radar.passes.Pass.get_range_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_range_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Computes the ``range-rates`` of all the states within the :class:`Pass`.</span>
<span class="sd">        </span>
<span class="sd">        The *range-rate* corresponds to the projection of the velocity vector in the ENU</span>
<span class="sd">        frame of reference along the range vector (pointing from the *station* to the *object*).</span>

<span class="sd">        Therefore, the range-rate will be negative if the object is getting closer to the station </span>
<span class="sd">        and positive otherwise.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        enu : numpy.ndarray (6, N)</span>
<span class="sd">            Space object&#39;s states in the *ENU* frame of the reference station.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        range_rates : numpy.ndarray</span>
<span class="sd">            Range-rates of the object at each time point.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        See :attr:`Pass.range_rate` to get a example.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Pass</span><span class="o">.</span><span class="n">calculate_range_rate</span><span class="p">(</span><span class="n">enu</span><span class="p">)</span> <span class="k">for</span> <span class="n">enu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">enu</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Pass</span><span class="o">.</span><span class="n">calculate_range_rate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">enu</span><span class="p">)</span></div>


<div class="viewcode-block" id="Pass.range_rate"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.range_rate.html#sorts.radar.passes.Pass.range_rate">[docs]</a>    <span class="k">def</span> <span class="nf">range_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns the ``range-rates`` of all the states within the :class:`Pass`.</span>
<span class="sd">        </span>
<span class="sd">        The *range-rate* corresponds to the projection of the velocity vector in the ENU</span>
<span class="sd">        frame of reference along the range vector (pointing from the *station* to the *object*).</span>

<span class="sd">        Therefore, the range-rate will be negative if the object is getting closer to the station </span>
<span class="sd">        and positive otherwise. </span>

<span class="sd">        .. note::</span>
<span class="sd">            if :attr:`Pass.cache` is True, *range-rates* will only be computed once on the</span>
<span class="sd">            first call of the function. Any future call will return the cached values.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        enu : numpy.ndarray (6, N)</span>
<span class="sd">            Space object&#39;s states in the *ENU* frame of the reference station.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        range_rates : numpy.ndarray</span>
<span class="sd">            Range-rates of the object at each time point.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider a space object (Kepler propagator) passing over the **EISCAT_3D** radar system:</span>

<span class="sd">        &gt;&gt;&gt; import sorts</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; radar = sorts.radars.eiscat3d</span>
<span class="sd">        &gt;&gt;&gt; Prop_cls = sorts.propagator.Kepler</span>
<span class="sd">        &gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">        ...     settings = dict(</span>
<span class="sd">        ...         out_frame=&#39;ITRS&#39;,</span>
<span class="sd">        ...         in_frame=&#39;TEME&#39;,</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Object</span>
<span class="sd">        &gt;&gt;&gt; space_object = sorts.SpaceObject(</span>
<span class="sd">        ...         Prop_cls,</span>
<span class="sd">        ...         propagator_options = Prop_opts,</span>
<span class="sd">        ...         a = 7000e3, </span>
<span class="sd">        ...         e = 0.0,</span>
<span class="sd">        ...         i = 78,</span>
<span class="sd">        ...         raan = 86,</span>
<span class="sd">        ...         aop = 0, </span>
<span class="sd">        ...         mu0 = 50,</span>
<span class="sd">        ...         epoch = 53005.0,</span>
<span class="sd">        ...         parameters = dict(</span>
<span class="sd">        ...             d = 0.1,</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; print(space_object)</span>
<span class="sd">        Space object 1: &lt;Time object: scale=&#39;utc&#39; format=&#39;mjd&#39; value=53005.0&gt;:</span>
<span class="sd">        a    : 7.0000e+06   x : -7.9830e+05</span>
<span class="sd">        e    : 0.0000e+00   y : 4.5663e+06</span>
<span class="sd">        i    : 7.8000e+01   z : 5.2451e+06</span>
<span class="sd">        omega: 0.0000e+00   vx: -1.4093e+03</span>
<span class="sd">        Omega: 8.6000e+01   vy: -5.6962e+03</span>
<span class="sd">        anom : 5.0000e+01   vz: 4.7445e+03</span>
<span class="sd">        Parameters: C_D=2.3, m=1.0, C_R=1.0, d=0.1</span>
<span class="sd">    </span>
<span class="sd">        The states are propagated over a time period of 1 day:</span>

<span class="sd">        &gt;&gt;&gt; t_states = sorts.equidistant_sampling(</span>
<span class="sd">        ...     orbit=space_object.state, </span>
<span class="sd">        ...     start_t=0, </span>
<span class="sd">        ...     end_t=3600.0, </span>
<span class="sd">        ...     max_dpos=10e3)</span>
<span class="sd">        &gt;&gt;&gt; object_states = space_object.get_state(t_states)</span>

<span class="sd">        The passes can then be found in the state array as follows:</span>

<span class="sd">        &gt;&gt;&gt; radar_passes = radar.find_passes(t_states, object_states, cache_data=True) </span>
<span class="sd">        &gt;&gt;&gt; radar_passes </span>
<span class="sd">        [[[Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, </span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7f1f904860c0&gt;] | Rise 0:04:05.161251 (4.4 min) 0:08:30.200441 Fall], </span>
<span class="sd">        [Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object </span>
<span class="sd">        at 0x7f1f903ca340&gt;] | Rise 0:04:05.161251 (4.3 min) 0:08:23.574462 Fall], [Pass Station [&lt;sorts.radar.system.</span>
<span class="sd">        station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object at 0x7f1f903eebc0&gt;] | Rise 0:04:05.</span>
<span class="sd">        161251 (4.1 min) 0:08:10.322502 Fall]]]</span>

<span class="sd">        To compute and plot the range rate over all the :class:`RX&lt;sorts.radar.system.station.RX&gt;` stations, run:</span>

<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(111)</span>
<span class="sd">        &gt;&gt;&gt; fmt = [&quot;-r&quot;, &quot;-g&quot;, &quot;-b&quot;]</span>
<span class="sd">        &gt;&gt;&gt; for rxi in range(len(radar.rx)):</span>
<span class="sd">        ...     ax.plot(t_states[radar_passes[0][rxi][0].inds], radar_passes[0][rxi][0].range_rate()[1], fmt[rxi], label=f&quot;Rx {rxi}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_xlabel(&quot;$t$ [$s$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_ylabel(&quot;$v_r_{rx}$ [$m/s$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.grid()</span>
<span class="sd">        &gt;&gt;&gt; ax.legend()</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">        Yiedlding: </span>

<span class="sd">        .. figure:: ../../../../figures/passes_example_range_rate.png</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_range_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_range_rate</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_rate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_range_rate</span><span class="p">()</span></div>


<div class="viewcode-block" id="Pass.get_zenith_angle"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.get_zenith_angle.html#sorts.radar.passes.Pass.get_zenith_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_zenith_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Computes the ``zenith angle`` of all the states within the :class:`Pass`.</span>
<span class="sd">        </span>
<span class="sd">        The *zenith angle* corresponds to angle between the local vertical of the reference</span>
<span class="sd">        station and the position vector (pointing from the *station* to the *object*).</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        zenith_angle : numpy.ndarray</span>
<span class="sd">            Range-rates of the object at each time point.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        See :attr:`Pass.zenith_angle` to get a example.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">Pass</span><span class="o">.</span><span class="n">calculate_zenith_angle</span><span class="p">(</span><span class="n">enu</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="n">radians</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">enu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">enu</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Pass</span><span class="o">.</span><span class="n">calculate_zenith_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">enu</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="n">radians</span><span class="p">)</span></div>


<div class="viewcode-block" id="Pass.zenith_angle"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.Pass.zenith_angle.html#sorts.radar.passes.Pass.zenith_angle">[docs]</a>    <span class="k">def</span> <span class="nf">zenith_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns the ``zenith angle`` of all the states within the :class:`Pass`.</span>
<span class="sd">        </span>
<span class="sd">        The *zenith angle* corresponds to angle between the local vertical of the reference</span>
<span class="sd">        station and the position vector (pointing from the *station* to the *object*).</span>

<span class="sd">        .. note::</span>
<span class="sd">            if :attr:`Pass.cache` is True, *zenith angle* will only be computed once on the</span>
<span class="sd">            first call of the function. Any future call will return the cached values.</span>


<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        zenith_angle : numpy.ndarray</span>
<span class="sd">            zenith angle of the object at each time point.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider a space object (Kepler propagator) passing over the **EISCAT_3D** radar system:</span>

<span class="sd">        &gt;&gt;&gt; import sorts</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; radar = sorts.radars.eiscat3d</span>
<span class="sd">        &gt;&gt;&gt; Prop_cls = sorts.propagator.Kepler</span>
<span class="sd">        &gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">        ...     settings = dict(</span>
<span class="sd">        ...         out_frame=&#39;ITRS&#39;,</span>
<span class="sd">        ...         in_frame=&#39;TEME&#39;,</span>
<span class="sd">        ...     ),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; space_object = sorts.SpaceObject(</span>
<span class="sd">        ...         Prop_cls,</span>
<span class="sd">        ...         propagator_options = Prop_opts,</span>
<span class="sd">        ...         a = 7000e3, </span>
<span class="sd">        ...         e = 0.0,</span>
<span class="sd">        ...         i = 78,</span>
<span class="sd">        ...         raan = 86,</span>
<span class="sd">        ...         aop = 0, </span>
<span class="sd">        ...         mu0 = 50,</span>
<span class="sd">        ...         epoch = 53005.0,</span>
<span class="sd">        ...         parameters = dict(</span>
<span class="sd">        ...             d = 0.1,</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; print(space_object)</span>
<span class="sd">        Space object 1: &lt;Time object: scale=&#39;utc&#39; format=&#39;mjd&#39; value=53005.0&gt;:</span>
<span class="sd">        a    : 7.0000e+06   x : -7.9830e+05</span>
<span class="sd">        e    : 0.0000e+00   y : 4.5663e+06</span>
<span class="sd">        i    : 7.8000e+01   z : 5.2451e+06</span>
<span class="sd">        omega: 0.0000e+00   vx: -1.4093e+03</span>
<span class="sd">        Omega: 8.6000e+01   vy: -5.6962e+03</span>
<span class="sd">        anom : 5.0000e+01   vz: 4.7445e+03</span>
<span class="sd">        Parameters: C_D=2.3, m=1.0, C_R=1.0, d=0.1</span>
<span class="sd">    </span>
<span class="sd">        The states are propagated over a time period of 1 day:</span>

<span class="sd">        &gt;&gt;&gt; t_states = sorts.equidistant_sampling(</span>
<span class="sd">        ...     orbit=space_object.state, </span>
<span class="sd">        ...     start_t=0, </span>
<span class="sd">        ...     end_t=3600.0, </span>
<span class="sd">        ...     max_dpos=10e3)</span>
<span class="sd">        &gt;&gt;&gt; object_states = space_object.get_state(t_states)</span>

<span class="sd">        The passes can then be found in the state array as follows:</span>

<span class="sd">        &gt;&gt;&gt; radar_passes = radar.find_passes(t_states, object_states, cache_data=True) </span>
<span class="sd">        &gt;&gt;&gt; radar_passes </span>
<span class="sd">        [[[Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, </span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7f1f904860c0&gt;] | Rise 0:04:05.161251 (4.4 min) 0:08:30.200441 Fall], </span>
<span class="sd">        [Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object </span>
<span class="sd">        at 0x7f1f903ca340&gt;] | Rise 0:04:05.161251 (4.3 min) 0:08:23.574462 Fall], [Pass Station [&lt;sorts.radar.system.</span>
<span class="sd">        station.TX object at 0x7f1f903e1ac0&gt;, &lt;sorts.radar.system.station.RX object at 0x7f1f903eebc0&gt;] | Rise 0:04:05.</span>
<span class="sd">        161251 (4.1 min) 0:08:10.322502 Fall]]]</span>

<span class="sd">        To compute and plot the zenith angle rate over all the :class:`RX&lt;sorts.radar.system.station.RX&gt;` stations, run:</span>

<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(111)</span>
<span class="sd">        &gt;&gt;&gt; fmt = [&quot;-r&quot;, &quot;-g&quot;, &quot;-b&quot;]</span>
<span class="sd">        &gt;&gt;&gt; for rxi in range(len(radar.rx)):</span>
<span class="sd">        ...     ax.plot(t_states[radar_passes[0][rxi][0].inds], radar_passes[0][rxi][0].zenith_angle()[1], fmt[rxi], label=f&quot;Rx {rxi}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_xlabel(&quot;$t$ [$s$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_ylabel(&quot;$\\theta_{rx}$ [$deg$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax.grid()</span>
<span class="sd">        &gt;&gt;&gt; ax.legend()</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">        Yiedlding: </span>

<span class="sd">        .. figure:: ../../../../figures/passes_example_zenith_angle.png</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zenith_angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_zenith_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_zenith_angle</span><span class="p">(</span><span class="n">radians</span><span class="o">=</span><span class="n">radians</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zenith_angle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_zenith_angle</span><span class="p">(</span><span class="n">radians</span><span class="o">=</span><span class="n">radians</span><span class="p">)</span></div></div>



<div class="viewcode-block" id="equidistant_sampling"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.equidistant_sampling.html#sorts.radar.passes.equidistant_sampling">[docs]</a><span class="k">def</span> <span class="nf">equidistant_sampling</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">start_t</span><span class="p">,</span> <span class="n">end_t</span><span class="p">,</span> <span class="n">max_dpos</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">eccentricity_tol</span><span class="o">=</span><span class="mf">0.3</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Finds the temporal sampling of an orbit which is sufficient to achieve a maximum spatial separation.</span>
<span class="sd">    </span>
<span class="sd">    Assuming an elleptic orbit, the ``equidistant_sampling`` function uses Keplerian propagation to find </span>
<span class="sd">    an equidistant sampling time array. In the case where eccentricity is small, periapsis speed </span>
<span class="sd">    and uniform sampling in time are used to generate the time array.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The current implementation does not take orbital perturbation patterns into account.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orbit : :class:`pyorb.Orbit` </span>
<span class="sd">        Orbit which is being sampled.</span>
<span class="sd">    start_t : float </span>
<span class="sd">        Start time (in seconds).</span>
<span class="sd">    end_t : float </span>
<span class="sd">        End time (in seconds).</span>
<span class="sd">    max_dpos : float </span>
<span class="sd">        Maximum separation between evaluation points (in meters).</span>
<span class="sd">    eccentricity_tol : float</span>
<span class="sd">        Minimum eccentricity below which the orbit is approximated as a circle and temporal samples are uniform in time.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray : </span>
<span class="sd">        Vector of sample times in seconds.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The :func:`equidistant_sampling` function is generally used to generate a time array over which </span>
<span class="sd">    the states of a space object are to be propagated. Consider the following space object:</span>

<span class="sd">    &gt;&gt;&gt; import sorts</span>
<span class="sd">    &gt;&gt;&gt; Prop_cls = sorts.propagator.Kepler</span>
<span class="sd">    &gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">    ...     settings = dict(</span>
<span class="sd">    ...         out_frame=&#39;ITRS&#39;,</span>
<span class="sd">    ...         in_frame=&#39;TEME&#39;,</span>
<span class="sd">    ...     ),</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; space_object = sorts.SpaceObject(</span>
<span class="sd">    ...         Prop_cls,</span>
<span class="sd">    ...         propagator_options = Prop_opts,</span>
<span class="sd">    ...         a = 7000e3, </span>
<span class="sd">    ...         e = 0.0,</span>
<span class="sd">    ...         i = 78,</span>
<span class="sd">    ...         raan = 86,</span>
<span class="sd">    ...         aop = 0, </span>
<span class="sd">    ...         mu0 = 50,</span>
<span class="sd">    ...         epoch = 53005.0,</span>
<span class="sd">    ...         parameters = dict(</span>
<span class="sd">    ...             d = 0.1,</span>
<span class="sd">    ...         ),</span>
<span class="sd">    ...     )</span>
<span class="sd">    &gt;&gt;&gt; print(space_object)</span>
<span class="sd">    Space object 1: &lt;Time object: scale=&#39;utc&#39; format=&#39;mjd&#39; value=53005.0&gt;:</span>
<span class="sd">    a    : 7.0000e+06   x : -7.9830e+05</span>
<span class="sd">    e    : 0.0000e+00   y : 4.5663e+06</span>
<span class="sd">    i    : 7.8000e+01   z : 5.2451e+06</span>
<span class="sd">    omega: 0.0000e+00   vx: -1.4093e+03</span>
<span class="sd">    Omega: 8.6000e+01   vy: -5.6962e+03</span>
<span class="sd">    anom : 5.0000e+01   vz: 4.7445e+03</span>
<span class="sd">    Parameters: C_D=2.3, m=1.0, C_R=1.0, d=0.1</span>

<span class="sd">    Given the initial state of the space object (which is described by a :class:`pyorb.Orbit` object),</span>
<span class="sd">    it is possible to generate an equidistant sampling time array to propagate the states of the </span>
<span class="sd">    space object over 1 day:</span>

<span class="sd">    &gt;&gt;&gt; t_states = sorts.equidistant_sampling(</span>
<span class="sd">    ...     orbit=space_object.state, </span>
<span class="sd">    ...     start_t=0, </span>
<span class="sd">    ...     end_t=3600.0, </span>
<span class="sd">    ...     max_dpos=10e3)</span>
<span class="sd">    &gt;&gt;&gt; t_states</span>
<span class="sd">    array([0.00000000e+00, 1.32519595e+00, 2.65039190e+00, ...,</span>
<span class="sd">       3.59658181e+03, 3.59790701e+03, 3.59923220e+03])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot use vectorized orbits: len(orbit) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">orbit</span><span class="o">.</span><span class="n">e</span> <span class="o">&lt;=</span> <span class="n">eccentricity_tol</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">pyorb</span><span class="o">.</span><span class="n">elliptic_radius</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">orbit</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">orbit</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">pyorb</span><span class="o">.</span><span class="n">orbital_speed</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">orbit</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">orbit</span><span class="o">.</span><span class="n">G</span><span class="o">*</span><span class="p">(</span><span class="n">orbit</span><span class="o">.</span><span class="n">M0</span> <span class="o">+</span> <span class="n">orbit</span><span class="o">.</span><span class="n">m</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start_t</span><span class="p">,</span> <span class="n">end_t</span><span class="p">,</span> <span class="n">max_dpos</span><span class="o">/</span><span class="n">v</span><span class="p">)</span>

    <span class="n">tmp_orb</span> <span class="o">=</span> <span class="n">orbit</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">tmp_orb</span><span class="o">.</span><span class="n">auto_update</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">tmp_orb</span><span class="o">.</span><span class="n">propagate</span><span class="p">(</span><span class="n">start_t</span><span class="p">)</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">tmp_orb</span><span class="o">.</span><span class="n">period</span>

    <span class="n">t_curr</span> <span class="o">=</span> <span class="n">start_t</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">t_curr</span><span class="p">]</span>
    <span class="n">t_repeat</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">while</span> <span class="n">t_curr</span> <span class="o">&lt;</span> <span class="n">end_t</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t_curr</span> <span class="o">-</span> <span class="n">start_t</span> <span class="o">&gt;</span> <span class="n">period</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t_repeat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">t_repeat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="n">t_repeat</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="n">t_repeat</span><span class="p">]</span>
            <span class="n">t_curr</span> <span class="o">+=</span> <span class="n">dt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">tmp_orb</span><span class="o">.</span><span class="n">speed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">max_dpos</span><span class="o">/</span><span class="n">v</span>
            <span class="n">t_curr</span> <span class="o">+=</span> <span class="n">dt</span>

            <span class="n">tmp_orb</span><span class="o">.</span><span class="n">propagate</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>

        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_curr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_passes"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.find_passes.html#sorts.radar.passes.find_passes">[docs]</a><span class="k">def</span> <span class="nf">find_passes</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">cache_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Finds all passes within the FOV of a radar :class:`sorts.Station&lt;sorts.radar.system.station.Station&gt;`</span>
<span class="sd">    given a set of space object states.</span>

<span class="sd">    In this implementation, a state is considered to be inside the field-of-view (FOV) of a station if the</span>
<span class="sd">    elevation of the target is **greater than the minimal elevation of the station beam**.  </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------    </span>
<span class="sd">    t : numpy.ndarray (N,) </span>
<span class="sd">        Vector of times in seconds to use as a base to find passes.</span>
<span class="sd">    states : numpy.ndarray (6, N) </span>
<span class="sd">        ECEF states of the object to find passes for.</span>
<span class="sd">    station : :class:`sorts.Station&lt;sorts.radar.system.station.Station&gt;`</span>
<span class="sd">        Radar station which defines the FOV.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    passes : list of :class:`Pass`</span>
<span class="sd">        List of passes over the radar station.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider a space object passing over the EISCAT_3D radar system:</span>

<span class="sd">    &gt;&gt;&gt; import sorts</span>
<span class="sd">    &gt;&gt;&gt; Prop_cls = sorts.propagator.Kepler</span>
<span class="sd">    &gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">    ...     settings = dict(</span>
<span class="sd">    ...         out_frame=&#39;ITRS&#39;,</span>
<span class="sd">    ...         in_frame=&#39;TEME&#39;,</span>
<span class="sd">    ...     ),</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; space_object = sorts.SpaceObject(</span>
<span class="sd">    ...         Prop_cls,</span>
<span class="sd">    ...         propagator_options = Prop_opts,</span>
<span class="sd">    ...         a = 7000e3, </span>
<span class="sd">    ...         e = 0.0,</span>
<span class="sd">    ...         i = 78,</span>
<span class="sd">    ...         raan = 86,</span>
<span class="sd">    ...         aop = 0, </span>
<span class="sd">    ...         mu0 = 50,</span>
<span class="sd">    ...         epoch = 53005.0,</span>
<span class="sd">    ...         parameters = dict(</span>
<span class="sd">    ...             d = 0.1,</span>
<span class="sd">    ...         ),</span>
<span class="sd">    ...     )</span>
<span class="sd">    &gt;&gt;&gt; print(space_object)</span>
<span class="sd">    Space object 1: &lt;Time object: scale=&#39;utc&#39; format=&#39;mjd&#39; value=53005.0&gt;:</span>
<span class="sd">    a    : 7.0000e+06   x : -7.9830e+05</span>
<span class="sd">    e    : 0.0000e+00   y : 4.5663e+06</span>
<span class="sd">    i    : 7.8000e+01   z : 5.2451e+06</span>
<span class="sd">    omega: 0.0000e+00   vx: -1.4093e+03</span>
<span class="sd">    Omega: 8.6000e+01   vy: -5.6962e+03</span>
<span class="sd">    anom : 5.0000e+01   vz: 4.7445e+03</span>
<span class="sd">    Parameters: C_D=2.3, m=1.0, C_R=1.0, d=0.1</span>

<span class="sd">    If the states are propagated over a time period of 1 day:</span>

<span class="sd">    &gt;&gt;&gt; t_states = sorts.equidistant_sampling(</span>
<span class="sd">    ...     orbit=space_object.state, </span>
<span class="sd">    ...     start_t=0, </span>
<span class="sd">    ...     end_t=3600.0, </span>
<span class="sd">    ...     max_dpos=10e3)</span>
<span class="sd">    &gt;&gt;&gt; space_object.get_state(t_states)</span>

<span class="sd">    we can identify the passes over the :class:`TX&lt;sorts.radar.system.station.TX&gt;`</span>
<span class="sd">    station of the EISCAT_3D radar by calling the function :func:`find_passes`:</span>

<span class="sd">    &gt;&gt;&gt; sorts.passes.find_passes(t_states, object_states, radar.tx[0], cache_data=True)</span>
<span class="sd">    [Pass Rise 0:04:05.161251 (4.4 min) 0:08:30.200441 Fall]</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">passes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># convert states to enu</span>
    <span class="n">enu</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">enu</span><span class="p">(</span><span class="n">states</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:])</span>
    
    <span class="c1"># mask all states outside the FOV</span>
    <span class="n">check</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">field_of_view</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">check</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">passes</span>

    <span class="c1"># get indices which mark the start and end of a :class:`Pass`</span>
    <span class="n">dind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dind</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">splits</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">splits</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">splits</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># split passes</span>
    <span class="n">splits</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">splits</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">ps_inds</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">splits</span><span class="p">[</span><span class="n">si</span><span class="p">]:</span><span class="n">splits</span><span class="p">[</span><span class="n">si</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">cache_data</span><span class="p">:</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">Pass</span><span class="p">(</span>
                <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="n">ps_inds</span><span class="p">],</span> 
                <span class="n">enu</span><span class="o">=</span><span class="n">enu</span><span class="p">[:,</span> <span class="n">ps_inds</span><span class="p">],</span> 
                <span class="n">inds</span><span class="o">=</span><span class="n">ps_inds</span><span class="p">,</span> 
                <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">Pass</span><span class="p">(</span>
                <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">enu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">inds</span><span class="o">=</span><span class="n">ps_inds</span><span class="p">,</span> 
                <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">ps_inds</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">ps_inds</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="n">passes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">passes</span></div>


<div class="viewcode-block" id="find_simultaneous_passes"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.find_simultaneous_passes.html#sorts.radar.passes.find_simultaneous_passes">[docs]</a><span class="k">def</span> <span class="nf">find_simultaneous_passes</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">cache_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; This function finds all passes (set of consecutive states) which lie *simultaneously*</span>
<span class="sd">    within the Field of View of a set of Radar stations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : numpy.ndarray of floats (N,)</span>
<span class="sd">        Vector of times in seconds to use as a base to find passes.</span>
<span class="sd">    states : numpy.ndarray of floats (6, N) </span>
<span class="sd">        ECEF states of the object to find passes for.</span>
<span class="sd">    stations : list of :class:`sorts.Station&lt;sorts.radar.system.station.Station&gt;` </span>
<span class="sd">        List of radar stations which define the field of view.</span>
<span class="sd">    cache_data : bool, default=True</span>
<span class="sd">        If ``True``, the states and time arrays will be stored within the passes.</span>

<span class="sd">        .. note:: </span>
<span class="sd">            Enabling this option will increase RAM usage.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    passes : list of :class:`Pass`</span>
<span class="sd">        list of passes which are associated with the specified field of view (and object).</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider a space object passing over the EISCAT_3D radar system:</span>

<span class="sd">    &gt;&gt;&gt; import sorts</span>
<span class="sd">    &gt;&gt;&gt; Prop_cls = sorts.propagator.Kepler</span>
<span class="sd">    &gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">    ...     settings = dict(</span>
<span class="sd">    ...         out_frame=&#39;ITRS&#39;,</span>
<span class="sd">    ...         in_frame=&#39;TEME&#39;,</span>
<span class="sd">    ...     ),</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; space_object = sorts.SpaceObject(</span>
<span class="sd">    ...         Prop_cls,</span>
<span class="sd">    ...         propagator_options = Prop_opts,</span>
<span class="sd">    ...         a = 7000e3, </span>
<span class="sd">    ...         e = 0.0,</span>
<span class="sd">    ...         i = 78,</span>
<span class="sd">    ...         raan = 86,</span>
<span class="sd">    ...         aop = 0, </span>
<span class="sd">    ...         mu0 = 50,</span>
<span class="sd">    ...         epoch = 53005.0,</span>
<span class="sd">    ...         parameters = dict(</span>
<span class="sd">    ...             d = 0.1,</span>
<span class="sd">    ...         ),</span>
<span class="sd">    ...     )</span>
<span class="sd">    &gt;&gt;&gt; print(space_object)</span>
<span class="sd">    Space object 1: &lt;Time object: scale=&#39;utc&#39; format=&#39;mjd&#39; value=53005.0&gt;:</span>
<span class="sd">    a    : 7.0000e+06   x : -7.9830e+05</span>
<span class="sd">    e    : 0.0000e+00   y : 4.5663e+06</span>
<span class="sd">    i    : 7.8000e+01   z : 5.2451e+06</span>
<span class="sd">    omega: 0.0000e+00   vx: -1.4093e+03</span>
<span class="sd">    Omega: 8.6000e+01   vy: -5.6962e+03</span>
<span class="sd">    anom : 5.0000e+01   vz: 4.7445e+03</span>
<span class="sd">    Parameters: C_D=2.3, m=1.0, C_R=1.0, d=0.1</span>

<span class="sd">    If the states are propagated over a time period of 1 day:</span>

<span class="sd">    &gt;&gt;&gt; t_states = sorts.equidistant_sampling(</span>
<span class="sd">    ...     orbit=space_object.state, </span>
<span class="sd">    ...     start_t=0, </span>
<span class="sd">    ...     end_t=3600.0, </span>
<span class="sd">    ...     max_dpos=10e3)</span>
<span class="sd">    &gt;&gt;&gt; space_object.get_state(t_states)</span>

<span class="sd">    we can identify the passes over the all the stations of the EISCAT_3D radar by </span>
<span class="sd">    calling the function :func:`find_simultaneous_passes`:</span>

<span class="sd">    &gt;&gt;&gt; sorts.passes.find_simultaneous_passes(t_states, object_states, radar.tx+radar.rx, cache_data=True)</span>
<span class="sd">    [Pass Station [&lt;sorts.radar.system.station.TX object at 0x7ff9af6ccac0&gt;, </span>
<span class="sd">    &lt;sorts.radar.system.station.RX object at 0x7ff99523ba40&gt;, </span>
<span class="sd">    &lt;sorts.radar.system.station.RX object at 0x7ff9951db2c0&gt;, </span>
<span class="sd">    &lt;sorts.radar.system.station.RX object at 0x7ff9951db4c0&gt;] | </span>
<span class="sd">    Rise 0:04:05.161251 (4.1 min) 0:08:10.322502 Fall]</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">passes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">enus</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),),</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    
    <span class="c1"># check if states are within the fov of each station</span>
    <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cache_data</span><span class="p">:</span>  <span class="c1"># convert states to enu in the reference frame of the station</span>
            <span class="n">enus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">station</span><span class="o">.</span><span class="n">enu</span><span class="p">(</span><span class="n">states</span><span class="p">))</span>

        <span class="n">check_st</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">field_of_view</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="n">check_st</span><span class="p">)</span>

    <span class="c1"># find all time indices which are within the fov of all stations</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">check</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">passes</span>

    <span class="c1"># compute splitting indices </span>
    <span class="n">split_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">split_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">split_ids</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">split_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">split_ids</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_ids</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">))</span>

    <span class="c1"># create pass objects for each identifed pass</span>
    <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">split_ids</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">==</span> <span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="c1"># pass data</span>
        <span class="k">if</span> <span class="n">cache_data</span><span class="p">:</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">Pass</span><span class="p">(</span>
                <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="p">]:</span><span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="o">+</span><span class="mi">1</span><span class="p">]]],</span> 
                <span class="n">enu</span><span class="o">=</span><span class="p">[</span><span class="n">enu</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">[</span><span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="p">]:</span><span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="o">+</span><span class="mi">1</span><span class="p">]]]</span> <span class="k">for</span> <span class="n">enu</span> <span class="ow">in</span> <span class="n">enus</span><span class="p">],</span> 
                <span class="n">inds</span><span class="o">=</span><span class="n">inds</span><span class="p">[</span><span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="p">]:</span><span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span> 
                <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">stations</span><span class="o">=</span><span class="n">stations</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">Pass</span><span class="p">(</span>
                <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">enu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">inds</span><span class="o">=</span><span class="n">inds</span><span class="p">[</span><span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="p">]:</span><span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span> 
                <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">stations</span><span class="o">=</span><span class="n">stations</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="p">]]]</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">_end</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">split_ids</span><span class="p">[</span><span class="n">pi</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">passes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">passes</span></div>


<div class="viewcode-block" id="group_passes"><a class="viewcode-back" href="../../../reference/radar/passes/auto/sorts.radar.passes.group_passes.html#sorts.radar.passes.group_passes">[docs]</a><span class="k">def</span> <span class="nf">group_passes</span><span class="p">(</span><span class="n">passes</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Takes a list of passes structured as ``passes[tx][rx][pass]`` and find all simultaneous passes and groups them </span>
<span class="sd">    according to ``[tx]``, resulting in a ``passes[tx][pass][rx]`` structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    passes : list of :class:`Pass`</span>
<span class="sd">        List of passes structured as ``passes[tx][rx][pass]``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    passes : list of :class:`Pass`</span>
<span class="sd">        List of passes structured as ``passes[tx][pass][rx]``.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">overlap</span><span class="p">(</span><span class="n">ps1</span><span class="p">,</span> <span class="n">ps2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ps1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ps2</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="ow">and</span> <span class="n">ps2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ps1</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

    <span class="n">grouped_passes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tx_passes</span> <span class="ow">in</span> <span class="n">passes</span><span class="p">:</span>
        <span class="n">grouped_passes</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

        <span class="c1">#first flatten</span>
        <span class="n">flat_passes</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">rx_passes</span> <span class="ow">in</span> <span class="n">tx_passes</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rx_passes</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_passes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">grouped_passes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">flat_passes</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_passes</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grouped_passes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                <span class="n">member</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">gps</span> <span class="ow">in</span> <span class="n">grouped_passes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">overlap</span><span class="p">(</span><span class="n">gps</span><span class="p">,</span> <span class="n">flat_passes</span><span class="p">[</span><span class="n">x</span><span class="p">]):</span>
                        <span class="n">member</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">member</span><span class="p">:</span>
                    <span class="n">member_id</span> <span class="o">=</span> <span class="n">y</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">member</span><span class="p">:</span>
                <span class="n">grouped_passes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">member_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flat_passes</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grouped_passes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">flat_passes</span><span class="p">[</span><span class="n">x</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">grouped_passes</span></div>

</pre></div>

              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright [2020-2022] Daniel Kastinen, Juha Vierinen, Thomas Maynadie.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>