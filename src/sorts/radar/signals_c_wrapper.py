#!/usr/bin/env python

'''This module is used to define the radar network configuration.

'''
import numpy as np
import ctypes

import scipy.constants
from sorts import clibsorts

doublep = ctypes.POINTER(ctypes.c_double)

#Define C interface
clibsorts.hard_target_snr.argtypes = [
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double, 
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    doublep,
]
clibsorts.hard_target_snr_vectorized.argtypes = [
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    ctypes.c_double,
    ctypes.c_double,
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    ctypes.c_double, 
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    ctypes.c_int
]
clibsorts.hard_target_diameter.argtypes = [
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    doublep,
]
clibsorts.hard_target_diameter_vectorized.argtypes = [
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    ctypes.c_double,
    ctypes.c_double,
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    ctypes.c_int,
]
clibsorts.incoherent_snr.argtypes = [
    ctypes.c_double, 
    ctypes.c_double, 
    ctypes.c_double, 
    ctypes.c_double, 
    ctypes.c_double, 
    doublep,
    doublep,
    doublep,
]
clibsorts.doppler_spread_hard_target_snr.argtypes = [
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    doublep,
    doublep,
]
clibsorts.doppler_spread_hard_target_snr_vectorized.argtypes = [
    ctypes.c_double,
    ctypes.c_double,
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    ctypes.c_double,
    ctypes.c_double,
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_double,
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    np.ctypeslib.ndpointer(dtype=ctypes.c_double),
    ctypes.c_int,
]


def hard_target_snr_scaling(diameter_from, diameter_to, wavelength):
    '''Determine the scaling constant `c` to convert the SNR generated by a 
    `diameter_from` target to a `diameter_to` target. I.e. by 
    `c SNR(diameter_from) = SNR(diameter_to)`.

    :param float diameter_from: object diameter of snr to convert from (meters)
    :param float diameter_to: object diameter of snr to convert to (meters)
    :param float wavelength: radar wavelength (meters)
    '''

    separator = wavelength/(np.pi*7.11**(1.0/4.0))
    # old_separator = wavelength/(np.pi*np.sqrt(3.0))
    
    if diameter_from < separator and diameter_to < separator:
        scale = diameter_to**6/diameter_from**6
    elif diameter_from < separator and diameter_to >= separator:
        scale = (wavelength**4*diameter_to**2)/(9*np.pi**4*diameter_from**6)
    elif diameter_from >= separator and diameter_to < separator:
        scale = (9*np.pi**4*diameter_to**6)/(wavelength**4*diameter_from**2)
    else:
        scale = diameter_to**6/diameter_from**6

    return scale


def hard_target_rcs(wavelength, diameter):
    '''Determine the radar cross section for a hard target.
    Assume a smooth transition between Rayleigh and optical scattering. 
    Ignore Mie regime and use either optical or Rayleigh scatter.

    :param float wavelength: radar wavelength (meters)
    :param float/numpy.ndarray diameter: diameter in meters of the objects.
    '''
    diameter = np.asfarray(diameter)
    wavelength = np.asfarray(wavelength)

    if diameter.any() <= 0:
        raise ValueError("diameter must be positive")

    if wavelength.any() <= 0:
        raise ValueError("wavelength must be a positive float")

    separator = wavelength/(np.pi*7.11**(1.0/4.0))
    # old_separator = wavelength/(np.pi*np.sqrt(3.0))

    # create masks
    is_rayleigh = diameter < separator
    is_optical = diameter >= separator
    
    # compute rcs
    optical_rcs = np.pi*diameter**2.0/4.0
    rayleigh_rcs = np.pi*diameter**2.0*7.11/4.0*(np.pi*diameter/wavelength)**4
    
    # get RCS values depending on the scattering regimes
    rcs = is_rayleigh*rayleigh_rcs + is_optical*optical_rcs
    
    return rcs 


def hard_target_snr(
        gain_tx, 
        gain_rx,
        wavelength,
        power_tx,
        range_tx_m, 
        range_rx_m,
        diameter=0.01, 
        bandwidth=10,
        rx_noise_temp=150.0,
        radar_albedo=1.0,
    ):
    '''
    Determine the signal-to-noise ratio (energy-to-noise) ratio for a hard target.
    Assume a smooth transition between Rayleigh and optical scattering. 
    Ignore Mie regime and use either optical or Rayleigh scatter.

    :param float/numpy.ndarray gain_tx: transmit antenna gain, linear
    :param float/numpy.ndarray gain_rx: receiver antenna gain, linear
    :param float wavelength: radar wavelength (meters)
    :param float power_tx: transmit power (W)
    :param float/numpy.ndarray range_tx_m: range from transmitter to target (meters)
    :param float/numpy.ndarray range_rx_m: range from target to receiver (meters)
    :param float diameter: object diameter (meters)
    :param float bandwidth: effective receiver noise bandwidth
    :param float rx_noise_temp: receiver noise temperature (K)
    :return: signal-to-noise ratio
    :rtype: float/numpy.ndarray


    **Reference:** Markkanen et.al., 1999
    
    '''

    N = np.size(gain_tx)

    if N == 1:
        snr = ctypes.c_double(0.0)
        
        clibsorts.hard_target_snr(
                ctypes.c_double(gain_tx), 
                ctypes.c_double(gain_rx),
                ctypes.c_double(wavelength),
                ctypes.c_double(power_tx),
                ctypes.c_double(range_tx_m), 
                ctypes.c_double(range_rx_m),
                ctypes.c_double(diameter), 
                ctypes.c_double(bandwidth),
                ctypes.c_double(rx_noise_temp),
                ctypes.c_double(radar_albedo),
                ctypes.c_double(scipy.constants.k),
                ctypes.byref(snr),
            )

        snr = snr.value
    else:
        gain_tx = np.asfarray(gain_tx)
        gain_rx = np.asfarray(gain_rx)

        range_tx_m = np.asfarray(range_tx_m)
        range_rx_m = np.asfarray(range_rx_m)

        snr = np.empty((N, ))
        
        clibsorts.hard_target_snr_vectorized(
                gain_tx, 
                gain_rx,
                ctypes.c_double(wavelength),
                ctypes.c_double(power_tx),
                range_tx_m, 
                range_rx_m,
                ctypes.c_double(diameter), 
                ctypes.c_double(bandwidth),
                ctypes.c_double(rx_noise_temp),
                ctypes.c_double(radar_albedo),
                ctypes.c_double(scipy.constants.k),
                snr,
                ctypes.c_int(N),
            )

    return snr


def hard_target_diameter(
            gain_tx, 
            gain_rx,
            wavelength,
            power_tx,
            range_tx_m, 
            range_rx_m,
            snr, 
            bandwidth=10,
            rx_noise_temp=150.0,
            radar_albedo=1.0,
        ):
    '''
    Determine the diamtere for a hard target based on the signal-to-noise ratio (energy-to-noise).
    Assume a smooth transition between Rayleigh and optical scattering. 
    Ignore Mie regime and use either optical or Rayleigh scatter.

    :param float/numpy.ndarray gain_tx: transmit antenna gain, linear
    :param float/numpy.ndarray gain_rx: receiver antenna gain, linear
    :param float wavelength: radar wavelength (meters)
    :param float power_tx: transmit power (W)
    :param float/numpy.ndarray range_tx_m: range from transmitter to target (meters)
    :param float/numpy.ndarray range_rx_m: range from target to receiver (meters)
    :param float snr: object signal to noise ratio (1)
    :param float bandwidth: effective receiver noise bandwidth
    :param float rx_noise_temp: receiver noise temperature (K)
    :return: diameter (meters)
    :rtype: float/numpy.ndarray


    **Reference:** Markkanen et.al., 1999
    
    '''
    N = np.size(gain_tx)

    if N == 1:
        diameter = ctypes.c_double(0.0)

        clibsorts.hard_target_diameter(
            ctypes.c_double(gain_tx), 
            ctypes.c_double(gain_rx),
            ctypes.c_double(wavelength),
            ctypes.c_double(power_tx),
            ctypes.c_double(range_tx_m), 
            ctypes.c_double(range_rx_m),
            ctypes.c_double(snr), 
            ctypes.c_double(bandwidth),
            ctypes.c_double(rx_noise_temp),
            ctypes.c_double(radar_albedo),
            ctypes.c_double(scipy.constants.k),
            ctypes.byref(diameter),
        )

        diameter = diameter.value
    else:
        gain_tx = np.asarray(gain_tx).astype(np.float64)
        gain_rx = np.asarray(gain_rx).astype(np.float64)

        range_tx_m = np.asarray(range_tx_m).astype(np.float64)
        range_rx_m = np.asarray(range_rx_m).astype(np.float64)
        snr = np.asarray(snr).astype(np.float64)

        diameter = np.empty((N, )).astype(np.float64)

        clibsorts.hard_target_diameter_vectorized(
            gain_tx, 
            gain_rx,
            ctypes.c_double(wavelength),
            ctypes.c_double(power_tx),
            range_tx_m, 
            range_rx_m,
            snr, 
            ctypes.c_double(bandwidth),
            ctypes.c_double(rx_noise_temp),
            ctypes.c_double(radar_albedo),
            ctypes.c_double(scipy.constants.k),
            diameter,
            ctypes.c_int(N),
        )

    return diameter

def incoherent_snr(signal_power, noise_power, epsilon=0.05, bandwidth=10.0, incoherent_integration_time=3600.0):
    ''' 
    Computes the incoherent signal to noise ratio and the minimal observation time required
    
    :param float signal_power: signal power (W)
    :param float noise_power: noise power (W)
    :param float epsilon: statistical significance criterion for a detection (-)
    :param float bandwidth: measurement bandwidth (Hz)
    :param float incoherent_integration_time: range from transmitter to target (meters)

    :return: signal to noise ratio (-)
    :return: incoherent signal to noise ratio (-)
    :return: minimal observation time (s)
    
    :rtype: float
    :rtype: float
    :rtype: float

    **Reference:** D. Kastinen et al.: Radar observability of near-Earth objects with EISCAT 3, 2020
    '''

    snr = ctypes.c_double(0.0)
    snr_incoh = ctypes.c_double(0.0)
    minimal_observation_time = ctypes.c_double(0.0)

    clibsorts.incoherent_snr(
        ctypes.c_double(signal_power), 
        ctypes.c_double(noise_power), 
        ctypes.c_double(epsilon), 
        ctypes.c_double(bandwidth), 
        ctypes.c_double(incoherent_integration_time),
        ctypes.byref(snr),
        ctypes.byref(snr_incoh),
        ctypes.byref(minimal_observation_time),
    )

    return snr.value, snr_incoh.value, minimal_observation_time.value,


def doppler_spread_hard_target_snr(
        t_obs, 
        spin_period, 
        gain_tx, 
        gain_rx,
        wavelength,
        power_tx,
        range_tx_m, 
        range_rx_m,
        duty_cycle=0.25,
        diameter=10.0, 
        bandwidth=10,
        rx_noise_temp=150.0,
        radar_albedo=0.1,
    ):
    ''' 
    Computes the coherent and incoherent signal to noise ratio for a spinning rigid object by taking into account the doppler shift
    
    :param float t_obs: measurement duration (s)
    :param float spin_period: rotation period of the object being observed (s)
    :param float/numpy.ndarray gain_tx: transmit antenna gain, linear (-)
    :param float/numpy.ndarray gain_rx: receiver antenna gain, linear (-)
    :param float wavelength: radar wavelength (m)
    :param float power_tx: transmit power (W)
    :param float/numpy.ndarray range_tx_m: range from transmitter to target (m)
    :param float/numpy.ndarray range_rx_m: range from target to receiver (m)
    :param float duty_cycle: RADAR measurement duty cycle (-)
    :param float diameter: object diameter (m)
    :param float bandwidth: effective receiver noise bandwidth (Hz)
    :param float rx_noise_temp: receiver noise temperature (K)
    :param float radar_albedo: RADAR albedo of the object beaing observed (-)

    :return: signal to noise ratio using coherent integration, when doing object discovery with a limited coherent integration duration and no incoherent integration
    :return: the signal to noise ratio using incoherent integration, when using a priori orbital elements to assist in coherent integration and incoherent integration. Coherent integration length is determined by t_obs (seconds)
    
    :rtype: float
    :rtype: float

    **Reference:** D. Kastinen et al.: Radar observability of near-Earth objects with EISCAT 3, 2020
    
    '''
    N = np.size(gain_tx)

    if N == 1:
        snr_coh = ctypes.c_double(0.0)
        snr_incoh = ctypes.c_double(0.0)

        clibsorts.doppler_spread_hard_target_snr(
            ctypes.c_double(t_obs),
            ctypes.c_double(spin_period),
            ctypes.c_double(gain_tx),
            ctypes.c_double(gain_rx),
            ctypes.c_double(wavelength),
            ctypes.c_double(power_tx),
            ctypes.c_double(range_tx_m),
            ctypes.c_double(range_rx_m),
            ctypes.c_double(duty_cycle),
            ctypes.c_double(diameter),
            ctypes.c_double(bandwidth),
            ctypes.c_double(rx_noise_temp),
            ctypes.c_double(radar_albedo),
            ctypes.c_double(scipy.constants.k),
            ctypes.byref(snr_coh),
            ctypes.byref(snr_incoh),
        )

        snr_coh = snr_coh.value
        snr_incoh = snr_incoh.value
    else:
        snr_coh = np.empty((N,)).astype(np.float64)
        snr_incoh = np.empty((N,)).astype(np.float64)

        gain_tx = np.asarray(gain_tx).astype(np.float64)
        gain_rx = np.asarray(gain_rx).astype(np.float64)
        range_tx_m = np.asarray(range_tx_m).astype(np.float64)
        range_rx_m = np.asarray(range_rx_m).astype(np.float64)

        clibsorts.doppler_spread_hard_target_snr_vectorized(
            ctypes.c_double(t_obs),
            ctypes.c_double(spin_period),
            gain_tx,
            gain_rx,
            ctypes.c_double(wavelength),
            ctypes.c_double(power_tx),
            range_tx_m,
            range_rx_m,
            ctypes.c_double(duty_cycle),
            ctypes.c_double(diameter),
            ctypes.c_double(bandwidth),
            ctypes.c_double(rx_noise_temp),
            ctypes.c_double(radar_albedo),
            ctypes.c_double(scipy.constants.k),
            snr_coh,
            snr_incoh,
            ctypes.c_int(N),
        )

    return snr_coh, snr_incoh