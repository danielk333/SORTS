.. currentmodule:: sorts.radar.scheduler

.. _schedulers:

================
Radar schedulers
================

1. Description
--------------
:ref:`schedulers` are used when multiple :class:`radar control sequences<sorts.radar.radar_controls.RadarControls>` are in conflict for a given :ref:`radar system<radars>`. They combine multiple radar control sequences (generated by different types of :ref:`controllers`). This is achieved by chosing the time slice which will be executed by the radar from the list of input control sequences by satisfying a set of scheduling constraints (specific to the type of scheduler). 

The research of new schedulers (optimizing the management of radar ressources) being an open research topic, SORTS defines a standard scheduler structure which can be used to define new scheduler types and simulate their results.

2. Why use a scheduler
----------------------
Let us take the example of a **radar measurement campain** where multiple scientists want to use the *same radar system to conduct different observations*. Each scientist will require a different set of :class:`radar controls<sorts.radar.radar_controls.RadarControls>`, which aren't necessarily compatible with each other. 

The :ref:`schedulers` module can be used to solve this problem as follow:
 - 	Each scientist can generate the controls he wants to perform with the radar (i.e. tracking of a meteoroid, random scan each 10s, ...).
  - A unique priority can be affected to each control.
  - The different controls are stacked into a single array.
  - Finally, one can call :attr:`scheduler.run<base.RadarSchedulerBase.run>` method to get a final control sequence which (hopefully) will satisfy the requirements of each scientist.


3. General scheduling procedure
-------------------------------
SORTS implementation of the scheduler generates the final control sequence in two main steps.

.. _time_slice_scheduling:

3.1. Scheduling of the time slices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The first step in generating the scheduled control sequence consists in **selecting which time slices from the original list of controls will be executed**. This selection can be made according to many different constraints (priority of the control/time slice, cost function, ...). 

When a time slice is considered as selected to be part of the final control sequence (output of the scheduler), the algorithm also stores the *index of the time slice* and of the *controller* which has generated it. This step facilitates the retreival of the pointing directions and of the controls after finishing the scheduling process.

.. _control_extraction_scheduler:

3.2. Extraction of the property and pointing direction controls
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This step consists in **copying the property and pointing directions controls** corresponding to the control sequence of the selected time slice into the final control sequence.

3.3. Example
~~~~~~~~~~~~
Consider a set of 3 control sequence which we want to schedule:

>>> controls = [controls1, controls2, controls3]

Such that

>>> controls1.t
array([0., 1., 2., 3., 4.])

>>> controls2.t
array([0., 5., 10.])

>>> controls3.t
array([1., 2.5, 3.25, 4.])

The **control sequence index** corresponds to the index that the considered control structure has inside the ``controls`` list. Suppose that after the first step (see :ref:`time_slice_scheduling`), the array of time slices and corresponding control indices are the following:

>>> time_slice_start # scheduler time slice start time (extracted from the control sequences) 
array([0., 1., 2., 2.5, 3., 3.25, 4., 5., 10.])
>>> control_index # indices controls which time slice have been selected by the scheduler at each time t.
array([0, 2, 0, 2, 0, 2, 2, 1, 1])
>>> time_slice_index # indices of the time slices inside there corresponding control sequence time slice array
array([0, 0, 1, 1, 2 2, 3, 1, 2])

The second step (see :ref:`control_extraction_scheduler`) consists in *copying the property and pointing direction controls* from each control time slice in ``time_slice_index`` and control sequence index within ``control_index``. Therefore, the final control sequence can be constructed as 

.. math:: \mathbf{p}_f = \{ \hspace{1mm} \mathbf{p}^i_j \hspace{2mm} | \hspace{2mm} ((i, j)_k \in E_{slices} \times E_{ctrl} | k \in [\![0, n[\![) \hspace{1mm} \}

with :math:`\mathbf{p}^i_j` the pointing direction of the :math:`j^{th}` control sequence at the :math:`i^{th}` time slice (:math:`E_{slices}` being ``time_slice_index`` and :math:`E_{ctrl}` being ``control_index``) and :math:`n` is the number of time slices within the final control structure. The same can be done for the property controls:

.. math:: \mathbf{x}_f = \{ \hspace{1mm} \mathbf{x}^i_j \hspace{2mm} | \hspace{2mm} ((i, j)_k \in E_{slices} \times E_{ctrl} | k \in [\![0, n[\![) \hspace{1mm} \}

with :math:`\mathbf{x}^i_j` the **targeted state vector of the radar system** defined by the :math:`j^{th}` control sequence at the :math:`i^{th}` time slice. 

4. API Reference
----------------

4.1. Scheduler Base Class
~~~~~~~~~~~~~~~~~~~~~~~~~
The :class:`sorts.RadarSchedulerBase<base.RadarSchedulerBase>` class defines the fundamental architecture of a radar scheduler.

.. autosummary::
	:toctree: auto/

	~base.RadarSchedulerBase

4.2. Predifined schedulers
~~~~~~~~~~~~~~~~~~~~~~~~~~
The current implementation of SORTS includes a single predifined :class:`scheduler<base.RadarSchedulerBase>` instance.

.. autosummary::
	:toctree: auto/

	~static_priority_scheduler.StaticPriorityScheduler