#!/usr/bin/env python

'''

'''

import numpy as np

from .scan import Scan

class Uniform(Scan):
    ''' Uniformly sample the FOV using Fibonacci lattice.
    
    The :class:`Uniform` scan class uniformly generates a set of uniformly sampled pointing
    directions using the Fibonacci lattice in the *ENU* coordinate frame.

    .. rubric:: Pointing direction parametrization :

    The pointing directions are generated using the **Fibonacci lattice** which is a method used to
    efficiently generate evenly distributed points on the surface of a sphere. This method relies on 
    the mapping of the Fibonacci lattice 

    .. math:: (x_i, y_i) = ( \\frac{i}{\\phi}, \\frac{i}{n} )

    where :math:`\\phi=(1+\\sqrt{5})/2` is called the *Golden ratio*, on the surface of a sphere. The 
    mapping transformation is:

    .. math:: (\\theta_i, \\phi_i) = ( 2 \\pi x, \\arccos{[1 - 2 y]} )
    
    therefore yielding the lattice:

    .. math:: (\\theta_i, \\phi_i) = ( 2 \\pi  \\frac{i}{\\phi}, \\arccos{[1 - 2 \\frac{i}{n}]} )

    .. note:: 
        All the points outside of the scan FOV (i.e. when the elevation is lower than ``min_elevation``) are discarded.
    
    The points are then converted from the *spherical* to *ENU* coordinate frame.

    .. rubric:: Constructor

    Parameters
    ----------
    min_elevation : float, default=30.0
        Minimum elevation of the beam. ``min_elevation`` also usually define the FOV of a station (in degrees).
    dwell : float, default=0.1
        Dwell time of the scan (in seconds).
    sph_num : int, default=1000
        Number of pointing directions generated by the scan.

    Examples
    --------
    As a simple example, consider a :class:`Uniform` scan performing the uniform random scanning of 
    a FOV defined by a minimum elevation of 30 degrees. The number of pointing directions per cycle is set 
    to be 20 and the dwell time as 1 second. 

    >>> import sorts
    >>> uniform = sorts.scans.Uniform(min_elevation=30.0, dwell=1.0, cycle_num=20)

    To evaluate the result of the ``pointing`` function, we create a time array of 10 elements :
    
    >>> t = np.linspace(0.0, 9.0, 10)
    >>> uniform.pointing(t)
    array([[ 0.3122499   0.3122499   0.3122499  -0.38843316 -0.38843316  0.05782668
           0.05782668  0.4623735   0.4623735  -0.8223979  -0.8223979   0.3122499
           0.3122499  -0.38843316 -0.38843316  0.05782668  0.05782668  0.4623735
           0.4623735  -0.8223979 ]
         [ 0.          0.          0.         -0.35583659 -0.35583659  0.65890521
           0.65890521 -0.60308436 -0.60308436  0.14547061  0.14547061  0.
           0.         -0.35583659 -0.35583659  0.65890521  0.65890521 -0.60308436
          -0.60308436  0.14547061]
         [ 0.95        0.95        0.95        0.85        0.85        0.75
           0.75        0.65        0.65        0.55        0.55        0.95
           0.95        0.85        0.85        0.75        0.75        0.65
           0.65        0.55      ]])

    
    To plot the results of the ``pointing`` function, we can use the :ref:`plotting` module implemented
    in sorts:

    >>> radar = sorts.radars.eiscat3d
    >>> sorts.plotting.plot_scanning_sequence(uniform, station=radar.tx[0], earth=True, ax=None, plot_local_normal=True, max_range=1000e3)
    
    .. figure:: ../../../../figures/scans_uniform.png

        Example :class:`Uniform` scanning scheme. In *blue*, the local vertical vector/in *red*, 
        the pointing direction vector of the tx station of the **EISCAT_3D radar**.
    '''
    def __init__(self, min_elevation=30.0, dwell=0.1, sph_num=1000):
        super().__init__(coordinates='enu')
        self._dwell = dwell
        ''' Dwell time of the scan (in seconds). '''
        self.min_elevation = min_elevation
        ''' Minimum elevation of the beam. ``min_elevation`` also usually defines the Field of view of the station (in degrees).'''
        self.num = sph_num
        ''' Number of pointing directions per scan cycle. '''
        self.sph_num = sph_num
        ''' Number of unifomly sampled points on the sphere. '''

        # generation of the Fibonacci lattice over the surface of a sphere of radius 1
        golden_ratio = (1 + 5**0.5)/2
        inds = np.arange(0, self.num)
        theta = 2 *np.pi * inds / golden_ratio
        phi = np.arccos(1 - 2*(inds + 0.5)/self.num)

        # converting spherical coordinates to ENU coordinates
        k = np.empty((3, self.num), dtype=np.float64)
        k[0,:] = np.cos(theta)*np.sin(phi)
        k[1,:] = np.sin(theta)*np.sin(phi)
        k[2,:] = np.cos(phi)

        # discarding points outside of the FOV of the station
        min_z = np.sin(np.radians(min_elevation))

        k = k[:, k[2,:] >= min_z]
        self.num = k.shape[1]
        ''' Number of pointing directions per scan cycle. '''
        self.pointings = k
        ''' Pointing direction in the ENU coordinate frame. '''


    def dwell(self, t=None):
        if t is None:
            return self._dwell
        else:
            if isinstance(t, float) or isinstance(t, int):
                return self._dwell
            else:
                return np.ones(t.shape, dtype=t.dtype)*self._dwell


    def min_dwell(self):
        return self._dwell


    def cycle(self):
        return self.num*self._dwell


    def pointing(self, t):
        ''' Returns the sequence of radar pointing directions at each given time points.

        The ``pointing`` function of the :class:`Uniform` class returns a set of randomly generated
        pointing directions in the ENU coordinate frame within the FOV of the scan.

        Parameters
        ----------
        t : float / numpy.ndarray (N,)
            Time point(s) (relative to the reference epoch) where the pointing directions are computed.
            The epoch of reference is relative to the definition of the pointing function.

        Returns
        -------
        pointing : numpy.ndarray (3, N)
            pointing directions programmed by the scanning scheme at each time point in the `ENU` coordinate
            frame.

        Examples
        --------
        See :class:`Uniform` for an in-depth example on how to generate a :class:`Uniform` 
        scanning scheme.
        '''
        ind = (np.mod(t/self.cycle(), 1)*self.num).astype(np.int)
        return self.pointings[:,ind]