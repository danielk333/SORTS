#!/usr/bin/env python

''' This module is used to define the radar network configuration. '''
import numpy as np
import scipy.constants

def hard_target_snr_scaling(diameter_from, diameter_to, wavelength):
    '''Determine the **scaling constant** `c` to convert the SNR generated by a 
    `diameter_from` target to a `diameter_to` target.

    The constant is computed by solving the equation :

    .. math::       SNR(R_1) = c SNR(R_2)

    For each of the possible scattering regimes (i.e. **Rayleigh** and **Optical**).
    
    .. rubric:: Syntax
 
    Parameters
    ----------
    diameter_from : float / numpy.ndarray
        object diameter of snr to convert from (in *meters*).
    diameter_to : float / numpy.ndarray
        object diameter of snr to convert to (in *meters*).
    wavelength : float / numpy.ndarray
        radar wavelength (in *meters*).

    Returns
    -------
    float/numpy.ndarray
        scaling constant `c` to convert the SNR generated by a `diameter_from` target to 
        a `diameter_to` target.

    Examples
    --------
    Consider a *monostatic* radar operating at 500 MHz observing a target with a diameter 
    of 1m. The scaling constant by which we need to multiply the SNR of the target of diameter
    1m to get the SNR of the target of 2m can be computed as follows:

    >>> import sorts
    >>> sorts.signals.hard_target_snr_scaling(1, 2, 0.6)
    64.0

    So a target of diameter 2m at 500 MHz has a SNR 64 times greater than a target of diameter
    1m.
    '''

    sep_const = wavelength/(np.pi*np.sqrt(3.0))
    
    if diameter_from < sep_const and diameter_to < sep_const:
        scale = diameter_to**6/diameter_from**6
    elif diameter_from < sep_const and diameter_to >= sep_const:
        scale = (wavelength**4*diameter_to**2)/(9*np.pi**4*diameter_from**6)
    elif diameter_from >= sep_const and diameter_to < sep_const:
        scale = (9*np.pi**4*diameter_to**6)/(wavelength**4*diameter_from**2)
    else:
        scale = diameter_to**6/diameter_from**6

    return scale


def hard_target_rcs(wavelength, diameter):
    ''' Compute the **Radar Cross-Section** (RCS) for a hard target.
    
    The implementation is based upon the assumption of a smooth transition between 
    the **Rayleigh** and **optical** scattering regimes. For simplification puroposes, it ignores 
    the *Mie* oscillatory regime and use either optical or Rayleigh scatter with the transition
    at 

    ..math::        D = \\frac{\\lambda}{\\pi \\sqrt{3}}

    Please refer to :ref:`_signals-theory-rcs` for more information.
    
    .. rubric:: Syntax
 
    Parameters
    ----------
    wavelength : float / numpy.ndarray
        Radar wavelength (in *meters*).
    diameter: float / numpy.ndarray
        Diameter of the objects (in *meters*).

    Returns
    -------
    float/numpy.ndarray :
        Estimated **Radar Cross-Section** (RCS) of the objects being observed.

    Examples
    --------
    Consider a *monostatic* radar operating at 500 MHz observing a target with a diameter of 10cm. 
    We can compute the estimated target RCS as follows:

    >>> import sorts
    >>> sorts.signals.hard_target_rcs(0.6, 0.1)
    0.005312841749744471

    So a target of diameter 10 cm at 500 MHz has a RCS value of :math:`0.005 m^2`.
    '''
    # masks
    is_rayleigh = diameter < wavelength/(np.pi*np.sqrt(3.0))
    is_optical = diameter >= wavelength/(np.pi*np.sqrt(3.0))
    
    # optical regime rcs
    optical_rcs = np.pi*diameter**2.0/4.0

    # rayleigh regime rcs
    rayleigh_rcs = 9.0*np.pi**5.0*diameter**6.0/(4.0*wavelength**4.0)
    
    rcs = is_rayleigh*rayleigh_rcs + is_optical*optical_rcs
    return rcs 


def hard_target_snr(
        gain_tx, 
        gain_rx,
        wavelength,
        power_tx,
        range_tx_m, 
        range_rx_m,
        diameter=0.01, 
        bandwidth=10,
        rx_noise_temp=150.0,
        radar_albedo=1.0,
    ):
    ''' Compute the signal-to-noise ratio for a hard target.

    A smooth transition between **Rayleigh** and **optical** scattering is assumed,  
    Therefore ignoring the *Mie regime*.

    The equation for the SNR is obtained by combining the expressions of the RCS for
    each scattering regimes (Optical/Rayleigh) given in :ref:`signals-theory-rcs`, 
    and the expressions of the Noise power given in :ref:`signals-theory-snr` to compute 
    the SNR.

    .. rubric:: Syntax
 
    Parameters
    ----------
    gain_tx : float / numpy.ndarray
        Transmit antenna gain, linear
    gain_rx : float / numpy.ndarray
        Receiver antenna gain, linear
    wavelength : float / numpy.ndarray
        Radar wavelength (meters)
    power_tx : float / numpy.ndarray
        Transmit power (W)
    range_tx_m : float / numpy.ndarray
        Range from transmitter to target (meters)
    range_rx_m : float / numpy.ndarray
        Range from target to receiver (meters)
    diameter : float / numpy.ndarray
        Object diameter (meters)
    bandwidth : float / numpy.ndarray
        Effective receiver noise bandwidth
    rx_noise_temp: float / numpy.ndarray
        Receiver noise temperature (K)

    Returns
    -------
    float / numpy.ndarray
        Estimated *Signal-to-Noise Ratio*

    References
    ----------
    .. [1] Measurements of small-size debris with backscatter of radio waves, J. Markkanen 
    et al., 1999, ESA contract report
    
    Examples
    --------
    Consider a *monostatic* radar of bandwidth 10 Hz, gain 40 dB, noise temperature 150 K 
    observing an object situated at a range 1000 km at frequency 500 MHz and power 5 MW. 
    Supposing that we get a SNR value of 44 dB, the function ``hard_target_diameter`` 
    will return the following result:

    >>> import sorts
    >>> sorts.signals.hard_target_snr(1e4, 1e4, 0.6, 5e6, 1000e3, 1000e3, 0.1, bandwidth=10, rx_noise_temp=150.0, radar_albedo=1.0)
    23269.93934963154
    >>> 10*np.log10(23269.93934963154)
    43.6679525135056

    So a target of diameter 10 cm will produce a SNR value of approximately 44 dB under 
    the previously described configuration.
    '''

    is_rayleigh = diameter < wavelength/(np.pi*np.sqrt(3.0))
    is_optical = diameter >= wavelength/(np.pi*np.sqrt(3.0))

    rayleigh_power = (9.0*power_tx*(((gain_tx*gain_rx)*(np.pi**2.0)*(diameter**6.0))/(256.0*(wavelength**2.0)*(range_rx_m**2.0*range_tx_m**2.0))))
    optical_power = (power_tx*(((gain_tx*gain_rx)*(wavelength**2.0)*(diameter**2.0)))/(256.0*(np.pi**2)*(range_rx_m**2.0*range_tx_m**2.0)))
    
    rx_noise = scipy.constants.k*rx_noise_temp*bandwidth
    snr = ((is_rayleigh)*rayleigh_power + (is_optical)*optical_power)*radar_albedo/rx_noise

    return snr

def hard_target_diameter(
            gain_tx, 
            gain_rx,
            wavelength,
            power_tx,
            range_tx_m, 
            range_rx_m,
            snr, 
            bandwidth=10,
            rx_noise_temp=150.0,
            radar_albedo=1.0,
        ):
    '''
    Determine the diameter for a hard target based on the Signal-to-Noise Ratio (SNR).
    A smooth transition between **Rayleigh** and **optical** scattering is assumed,  
    Therefore ignoring the *Mie regime*.

    The equation for the object diameter is obtained by combining the expressions of the RCS for
    each scattering regimes (Optical/Rayleigh) given in :ref:`signals-theory-rcs`, 
    and the expressions of the Noise power given in :ref:`signals-theory-snr` to compute 
    the SNR.

    .. rubric:: Syntax
 
    Parameters
    ----------
    gain_tx : float / numpy.ndarray
        Transmit antenna gain (-).
    gain_rx : float / numpy.ndarray
        Receiver antenna gain (-).
    wavelength : float / numpy.ndarray
        Radar wavelength (m).
    power_tx : float / numpy.ndarray
        Transmit power (W).
    range_tx_m : float / numpy.ndarray
        Range from transmitter to target (m).
    range_rx_m : float/ n umpy.ndarray
        Range from target to receiver (m).
    snr : float / numpy.ndarray
        Object signal to noise ratio (-).
    bandwidth : float / numpy.ndarray
        Effective receiver noise bandwidth (Hz).
    rx_noise_temp : float / numpy.ndarray
        Receiver noise temperature (K).

    Returns
    -------
    float / numpy.ndarray
        Object diameter (in meters).

    References
    ----------
    .. [1] Measurements of small-size debris with backscatter of radio waves, J. 
    Markkanen et. al., 1999, ESA contract report

    Examples
    --------
    Consider a *monostatic* radar of bandwidth 10 Hz, gain 40 dB, noise temperature 
    150 K observing an object situated at a range 1000 km at frequency 500 MHz and 
    power 5 MW. Supposing that we get a SNR value of 44 dB, the function 
    ``hard_target_diameter`` will return the following result:

    >>> import sorts
    >>> sorts.signals.hard_target_diameter(1e4, 1e4, 0.6, 5e6, 1000e3, 1000e3, 10**(44/10.0), bandwidth=10, rx_noise_temp=150.0, radar_albedo=1.0):
    0.1012824328560151

    So the target diameter needed to produce a SNR value of :math:`44 dB` with 
    the previously described configuration is 10 cm
    '''

    rx_noise = scipy.constants.k*rx_noise_temp*bandwidth
    power = snr*rx_noise/radar_albedo

    diameter_rayleigh = (256.0*(wavelength**2.0)*(range_rx_m**2.0*range_tx_m**2.0)*power/(9.0*power_tx*(gain_tx*gain_rx)*(np.pi**2.0)))**(1.0/6.0)
    diameter_optical = np.sqrt(256.0*(np.pi**2)*(range_rx_m**2.0*range_tx_m**2.0)*power/(power_tx*(gain_tx*gain_rx)*(wavelength**2.0)))

    separatrix = wavelength/(np.pi*np.sqrt(3.0))

    is_rayleigh = np.logical_and(diameter_rayleigh < separatrix, diameter_optical < separatrix)
    is_optical = np.logical_and(diameter_rayleigh >= separatrix, diameter_optical >= separatrix)

    diameter = (is_rayleigh)*diameter_rayleigh + (is_optical)*diameter_optical

    return diameter

def incoherent_snr(signal_power, noise_power, epsilon=0.05, bandwidth=10.0, incoherent_integration_time=3600.0):
    ''' 
    Compute the **incoherent Signal-to-Noise Ratio** and the **minimal observation time** required.

    .. rubric:: Theorical background

    The **Signal-to-Noise Ratio** after performing an incoherent integration over an observation period 
    :math:`\\tau_{obs}` can be expressed as:

    .. math:: SNR_{inc} = \\frac{P_s}{P_{N,inc}} \\sqrt{B_{inc} \\tau_{obs}}

    where :math:`P_{N,inc} = \\frac{k_B T_{tx} B_{inc}}{\\eta}` is the incoherent noise power.

    The **minimal observation time** :math:`\\tau_{obs}` is the time interval needed to achieve a
    probability of false detection :math:`\\epsilon` such as:

    .. math:: \\tau_{obs} = \\frac{(P_s + P_{N,inc})^2}{\\epsilon^2 P_s^2 B_{inc}}
    
    .. rubric:: Syntax

    Parameters
    ----------
    signal_power : float / numpy.ndarray
        Signal power (W).
    noise_power : float
        Noise power (W).
    epsilon : float
        Statistical significance criterion for a detection (-).
    bandwidth : float
        Measurement bandwidth (Hz).
    incoherent_integration_time : float
        Range from transmitter to target (meters).
    
    Returns
    -------
    snr : float / numpy.ndarray
        Signal to noise ratio (-)
    snr_incoh : float / numpy.ndarray
        Incoherent signal to noise ratio (-)
    minimal_observation_time : float / numpy.ndarray
        Minimal observation time (s)

    References
    ----------
    .. [1] Radar observability of near-Earth objects with EISCAT 3D, D. Kastinen et. al., 2020

    Examples
    --------
    If we consider a received signal of power :math:`15 \\cdot 10^{-19} W`, of incoherent 
    integration bandwidth 10 Hz, incoherently integrated over a time period of 
    3600 seconds with a noise power of :math:`2.1 \\cdot 10^{-20} W`, we have:

    >>> import sorts
    >>> sorts.incoherent_snr(15e-19, 2.1e-20, epsilon=0.05, bandwidth=10.0, incoherent_integration_time=3600.0)
    (71.42857142857143, 13552.618543578768, 41.127839999999985)

    Here, we have set a confidence level to get a 5% probability of false detection, which yields 
    an SNR value of 18.5 dB, an incoherent SNR value of 41.3 dB and a minimal observation time of 
    41.1 seconds.
    '''
    # Compute the signal to noise ratio
    snr = signal_power/noise_power
    
    # compute the minimum required observation time needed to reduce the relative error to epsilon as follows
    minimal_observation_time = ((signal_power + noise_power)**2.0)/(epsilon**2.0*signal_power**2.0*bandwidth)
    
    # Compute the incoherent signal to noise ratio
    n_measurement = int(incoherent_integration_time * bandwidth)
    snr_incoh = snr*np.sqrt(n_measurement)
    
    return snr, snr_incoh, minimal_observation_time

def doppler_spread_hard_target_snr(
        t_obs, 
        spin_period, 
        gain_tx, 
        gain_rx,
        wavelength,
        power_tx,
        range_tx_m, 
        range_rx_m,
        duty_cycle=0.25,
        diameter=10.0, 
        bandwidth=10,
        rx_noise_temp=150.0,
        radar_albedo=0.1,
    ):
    ''' Compute the **coherent** and **incoherent** Signal-to-Noise ratio for a spinning rigid object by taking 
    into account the *Doppler shift*.

    .. rubric:: Theorical background

    First, the **doppler bandwidth** of the scattered signal due to the rotation of the object around its own
    orbit is calculated using the relation 

    .. math::            B_{doppler} = \\frac{4 \\pi D}{\\lambda \\tau_s}

    with :math:`D` the diameter of the object, :math:`\\lambda` the wavelength of the radar signal and :math:`\\tau_s`
    the rotation period of the object around its own axis.

    The **measurement bandwidth** :math:`B_{m}` corresponds to the maximum bandwidth between the observation bandwidth 
    :math:`B_{obs} = 1/ \\tau_{obs}`, the effective signal bandwidth :math:`B_{s} = \\beta_{rx} \\eta` (:math:`\\beta_{rx}`
    corresponds to the bandwidth of the receiver and :math:`\\eta` the transmitter duty cycle) and the Doppler bandwdth 
    :math:`B_{doppler}`. On the other hand, the **incoherent integration** bandwidth math:`B_{inc}` corresponds to the maximum bandwidth
    between :math:`B_{doppler}` and :math:`B_{obs}`.

    After computing the *SNR* and the *receiver noise power* (see :ref:`signals-theory-snr`), it is then possible to 
    compute the actual *signal power*. We can then compute the **coherent noise power**:

    .. math:: P_{N,coh} = \\frac{k_B T_{tx} B_m}{\\eta}

    and compute the **incoherent SNR** :math:`SNR_{coh} = P_s/P_{N,coh}`. Finally, the **incoherent noise power** can be expressed
    as:

    .. math:: P_{N,inc} = \\frac{k_B T_{tx} B_{inc}}{\\eta}

    From which we can deduce the **incoherent SNR**:

    .. math:: SNR_{inc} = \\frac{P_s}{P_{N,inc}} \\sqrt{B_{inc} \\tau_{obs}}


    .. rubric:: Syntax

    Parameters
    ----------
    t_obs : float / numpy.ndarray
        Measurement duration (s)
    spin_period : float / numpy.ndarray
        Rotation period of the object being observed (s)
    gain_tx : float / numpy.ndarray
        Transmit antenna gain, linear (-)
    gain_rx : float / numpy.ndarray
        Receiver antenna gain, linear (-)
    wavelength : float / numpy.ndarray
        Radar wavelength (m)
    power_tx : float / numpy.ndarray
        Transmit power (W)
    range_tx_m : float / numpy.ndarray
        Range from transmitter to target (m)
    range_rx_m : float / numpy.ndarray
        Range from target to receiver (m)
    duty_cycle : float / numpy.ndarray
        RADAR measurement duty cycle (-)
    diameter : float / numpy.ndarray
        Object diameter (m)
    bandwidth : float / numpy.ndarray
        Effective receiver noise bandwidth (Hz)
    rx_noise_temp : float / numpy.ndarray
        Receiver noise temperature (K)
    radar_albedo : float / numpy.ndarray
        Radar albedo of the object beaing observed (-)

    Returns
    -------
    snr_coh : float / numpy.ndarray
        Signal-to-Noise Ratio (SNR) using **coherent integration**, when doing object discovery with a limited 
        coherent integration duration and no incoherent integration

    snr_incoh : float / numpy.ndarray
        Signal-to-Noise Ratio (SNR) using **incoherent integration**.

    Examples
    --------
    A simple example using the ``doppler_spread_hard_target_snr`` consists in calculating the **SNR** (coherent/incoherent) 
    for a specific space object/radar arrangement. This SNR value can then be compated to a threshold value to determine 
    if the space object would have been detected with the current system configuration.

    .. code-block:: Python

        import numpy as np
        import sorts

        # intitializes the radar
        radar = sorts.radars.eiscat3d

        # point stations towards local vertical
        k0 = np.array([0,0,1])
        radar.tx[0].beam.point(k0)
        radar.rx[0].beam.point(k0)

        # compute incoherent and coherent SNR
        snr_coh, snr_incoh = sorts.signals.doppler_spread_hard_target_snr(
            3600.0, 
            gain_tx = radar.tx[0].beam.gain(k0),
            gain_rx = radar.rx[0].beam.gain(k0),
            wavelength = radar.tx[0].wavelength,
            power_tx = radar.tx[0].power,
            range_tx_m = 300000e3, 
            range_rx_m = 300000e3,
            duty_cycle=0.25,
            bandwidth=10,
            rx_noise_temp=150.0,
            diameter=150.0,
            spin_period=500.0,
            radar_albedo=0.1,
        )

    References
    ----------
    .. [1] Radar observability of near-Earth objects with EISCAT 3D, D. Kastinen et. al., 2020
    '''
    
    # compute the bandwidth of the doppler shifted RADAR echo
    doppler_bandwidth = 4.0*np.pi*diameter/(wavelength*spin_period)
    
    # measurement bandwidth (coherent integration)
    measurement_bandwidth = np.max([doppler_bandwidth, bandwidth*duty_cycle, 1.0/t_obs]) # coherent : for serendipitous discovery

    # measurement bandwidth with incoherent integration, when a priori information about the target is available
    base_int_bandwidth = np.max([doppler_bandwidth, 1.0/t_obs])
    
    # Compute signal properties
    h_snr = hard_target_snr(    # compute standard hard target SNR
        gain_tx = gain_tx, 
        gain_rx = gain_rx,
        wavelength = wavelength,
        power_tx = power_tx,
        range_tx_m = range_tx_m, 
        range_rx_m = range_rx_m,
        diameter = diameter, 
        bandwidth = bandwidth,
        rx_noise_temp = rx_noise_temp,
        radar_albedo = radar_albedo,
    )
    
    rx_noise = scipy.constants.k * rx_noise_temp * bandwidth # compute the noise measured by the receiver
    signal_power = h_snr * rx_noise # compute the noised measured by the receiver
    
    # compute the SNR
    # coherent : effective noise power when using just coherent integration
    coh_noise_power = scipy.constants.k * rx_noise_temp * measurement_bandwidth/duty_cycle
    snr_coh = signal_power/coh_noise_power
    
    # incoherent : effective noise power when doing incoherent integration and using a good a priori orbital elements
    incoh_noise_power = scipy.constants.k * rx_noise_temp * base_int_bandwidth/duty_cycle

    snr, snr_incoh, te = incoherent_snr(signal_power, incoh_noise_power, bandwidth=base_int_bandwidth, incoherent_integration_time=t_obs)
    
    return snr_coh, snr_incoh
