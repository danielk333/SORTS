
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sorts.radar.controllers.space_object_tracker &#8212; SORTS v4.0 Manual</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "dark";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="None">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="dark">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
  
    <p class="title logo__title">SORTS v4.0 Manual</p>
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../intro.html">
  Introduction
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../install.html">
  Installation
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../usermanual.html">
  SORTS Manual
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/danielk333/sorts" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <h1>Source code for sorts.radar.controllers.space_object_tracker</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">ctypes</span>

<span class="kn">import</span> <span class="nn">pyorb</span>
<span class="kn">from</span> <span class="nn">astropy.time</span> 		<span class="kn">import</span> <span class="n">Time</span><span class="p">,</span> <span class="n">TimeDelta</span>

<span class="kn">from</span> <span class="nn">...common</span> 			<span class="kn">import</span> <span class="n">interpolation</span>
<span class="kn">from</span> <span class="nn">...common</span> 			<span class="kn">import</span> <span class="n">multiprocessing_tools</span> <span class="k">as</span> <span class="n">mptools</span>
<span class="kn">from</span> <span class="nn">..system.radar</span>		<span class="kn">import</span> <span class="n">Radar</span>
<span class="kn">from</span> <span class="nn">..passes</span> 			<span class="kn">import</span> <span class="n">find_simultaneous_passes</span><span class="p">,</span> <span class="n">equidistant_sampling</span>
<span class="kn">from</span> <span class="nn">..</span>					<span class="kn">import</span> <span class="n">radar_controls</span>
<span class="kn">from</span> <span class="nn">.</span>					<span class="kn">import</span> <span class="n">Tracker</span><span class="p">,</span> <span class="n">radar_controller</span>


<div class="viewcode-block" id="SpaceObjectTracker"><a class="viewcode-back" href="../../../../reference/controllers/auto/sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.html#sorts.radar.controllers.space_object_tracker.SpaceObjectTracker">[docs]</a><span class="k">class</span> <span class="nc">SpaceObjectTracker</span><span class="p">(</span><span class="n">radar_controller</span><span class="o">.</span><span class="n">RadarController</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	This class allows the used to easily track multiple space objects based on their priority. It will generate a set of pointing directions compatible with the </span>
<span class="sd">	specified Radar system over the given time interval.</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="n">META_FIELDS</span> <span class="o">=</span> <span class="n">radar_controller</span><span class="o">.</span><span class="n">RadarController</span><span class="o">.</span><span class="n">META_FIELDS</span>

<div class="viewcode-block" id="SpaceObjectTracker.__init__"><a class="viewcode-back" href="../../../../reference/controllers/auto/sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.__init__.html#sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.__init__">[docs]</a>	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">profiler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">		This class can be used to generate a set of states (ECEF frame) which allow for the tracking of multiple space objects while satisfying a set of observational </span>
<span class="sd">		requirements.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">			logger (optional) : logging.logger</span>
<span class="sd">				logger instance used to log comptutation status on the terminal</span>
<span class="sd">			profiler (optional) : sorts.profiling.profiler</span>
<span class="sd">				profiler instance used to monitor the computational performances of the class&#39; functions</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">profiler</span><span class="o">=</span><span class="n">profiler</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">tracker_controller</span> <span class="o">=</span> <span class="n">Tracker</span><span class="p">(</span><span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">profiler</span><span class="o">=</span><span class="n">profiler</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;SpaceObjectTracker:Init&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpaceObjectTracker.compute_pointing_directions"><a class="viewcode-back" href="../../../../reference/controllers/auto/sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.compute_pointing_directions.html#sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.compute_pointing_directions">[docs]</a>	<span class="k">def</span> <span class="nf">compute_pointing_directions</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span> 
		<span class="n">controls</span><span class="p">,</span>
		<span class="n">period_id</span><span class="p">,</span> 
		<span class="n">args</span><span class="p">,</span>
	<span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">		Computes the pointing directions over the specified period id. This method is used automatically by the RadarControls class to generate the </span>
<span class="sd">		tracking pointing directions. </span>

<span class="sd">		As such, the user can indirectly call this method by calling tracking_controls.get_pdirs(period_id) where tracking_controls is an instance</span>
<span class="sd">		of RadarControls which has been created by the SpaceObjectTracker controller.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">			controls : sorts.RadarControls</span>
<span class="sd">				radar controls instance used to store the Radar controls generated by the SpaceObjectTracker controller.</span>

<span class="sd">			period_id : int</span>
<span class="sd">				index of the control period which corresponding pointing directions are to be computed. see RadarControls documentation for more information.</span>

<span class="sd">			args : list</span>
<span class="sd">				set of aditional arguments (relative to the compute_pointing_direction implementation of the controller) used to compute the Radar pointing</span>
<span class="sd">				directions. In the case of the SpaceObjectTracker controller args = (final_states, final_t_tracking), which correspond to the </span>
<span class="sd">				array of interpolated states and time points where pointing directions are to be computed</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracker_controller</span><span class="o">.</span><span class="n">compute_pointing_direction</span><span class="p">(</span>
			<span class="n">controls</span><span class="p">,</span>
			<span class="n">period_id</span><span class="p">,</span> 
			<span class="n">args</span><span class="p">,</span>
		<span class="p">)</span></div>

<div class="viewcode-block" id="SpaceObjectTracker.generate_controls"><a class="viewcode-back" href="../../../../reference/controllers/auto/sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.generate_controls.html#sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.generate_controls">[docs]</a>	<span class="k">def</span> <span class="nf">generate_controls</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span> 
		<span class="n">t</span><span class="p">,</span> 
		<span class="n">radar</span><span class="p">,</span> 
		<span class="n">space_objects</span><span class="p">,</span> 
		<span class="n">epoch</span><span class="p">,</span> 
		<span class="n">t_slice</span><span class="p">,</span> 
		<span class="n">states_per_slice</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
		<span class="n">space_object_priorities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
		<span class="n">priority</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
		<span class="n">interpolator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
		<span class="n">max_dpos</span><span class="o">=</span><span class="mf">50e3</span><span class="p">,</span> 
		<span class="n">max_samp</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> 
		<span class="n">max_processes</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
		<span class="n">scheduler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
		<span class="n">max_points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
		<span class="n">save_states</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
		<span class="n">cache_pdirs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
	<span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This method can be called to generate a sequence of radar controls which allow for the tracking of multiple space objects. The generated controls will</span>
<span class="sd">		contain the pointing directions for each radar station. </span>

<span class="sd">		The current implementation of this algorithm relies on the concept of static priority to choose which space object will be tracked at a given time t. </span>
<span class="sd">		It is important to note that when a specific space object is chosen for tracking at the start of the time slice, this object will remain tracked until</span>
<span class="sd">		then end of the time slice, even if a higher priority object enters the field of view.</span>

<span class="sd">		The generate_controls method consists of two distinct parts :</span>
<span class="sd">			- First the states of each space object are propagated over the whole control time interval (given by t). When all the states are computed, data </span>
<span class="sd">			reduction will be achieved by removing all the states lying outside of the radar system field of view. Finally, the tracking schedule (i.e. the </span>
<span class="sd">			choice of which space object to follow) will be done according to the priority of each space object.</span>
<span class="sd">			- When the tracking schedule is generated, the algorithm will then perform an interpolation to the $i^{th}$ object for all tracking instants $t_{ik}$</span>
<span class="sd">			associated with this space object. </span>

<span class="sd">		As an example, consider that we want to track 3 space objects (0, 1, 2) of priority (0, 1, 2) at times $t = [0, 10, 20, 30]$</span>

<span class="sd">		The first part of the algorithm has propagated the states and has found the following passes (sequence of points inside the FOV of all stations) :</span>

<span class="sd">			- Object 0 (p = 0) :		$t_0^p = [10, 15]$</span>
<span class="sd">			- Object 1 (p = 1) :		$t_0^p = [30]$</span>
<span class="sd">			- Object 2 (p = 2) :		$t_0^p = [10, 20, 30]$</span>

<span class="sd">		Since all objects are outside the radar&#39;s FOV at time 0, we can remove the control time slice at $t=0$, yielding $t = [10, 20, 30]$. We can then </span>
<span class="sd">		follow an iterative procedure : first we create an array containing the index of the space object beaing tracked during the time slice $t_k$ :</span>

<span class="sd">			$C = [-1 \hspace{1.5mm} -1 \hspace{1.5mm} -1]$</span>

<span class="sd">		Looking at the first object, we can see that at time $t = 10s$, the object will be inside the radar FOV. Therefore, we allocate the first time slice </span>
<span class="sd">		to the tracking of this space object :</span>

<span class="sd">			$C = [0 \hspace{1.5mm} -1 \hspace{1.5mm} -1]$</span>

<span class="sd">		Then, we see that the second space object is inside the stations&#39; FOV at time $t = 30s$. Since there are no conflicts with other space objects at this time,</span>
<span class="sd">		we allocate the last time slice to the tracking of this space object :</span>

<span class="sd">			$C = [0 \hspace{1.5mm} -1 \hspace{1.5mm} 1]$</span>

<span class="sd">		Finally, we can see that the last space object is visible during the whole control interval, but the first and last time slices are already allocated for </span>
<span class="sd">		the tracking of higher priority objects. Therefore, the middle time slice will be allocated for the tracking of the last space object :</span>

<span class="sd">			$C = [0 \hspace{1.5mm} 2 \hspace{1.5mm} 1]$</span>

<span class="sd">		The last part of this algorithm consists in computing the states of the objects at each tracking point, and then computing the pointing directions for</span>
<span class="sd">		each station.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">		t : np.ndarray</span>
<span class="sd">			Start time of a Tracking time slice. This array limits the controls time interval between t[0] and t[-1], but please note that if no space objects are found </span>
<span class="sd">			at a given time slice, the latter will be discarded so that the final conrtol array only contains time slices allocated for the observation of a space object.</span>

<span class="sd">			Each time slice $T_s^i$ is defined by its start time $t^i$ (contained in the t array) and its duration $t_{slice}^i$ (contained in the t_slice array)</span>

<span class="sd">		radar : sorts.radar.system.Radar</span>
<span class="sd">			Radar instance being controlled to track the space objects. This instance is used for the computations of the station pointing directions and for the </span>
<span class="sd">			checking of a space object visibility. </span>

<span class="sd">		space_objects : list/np.ndarray of sorts.targets.SpaceObject</span>
<span class="sd">			Array of space objects to be observed during the specified time interval (t[0], t[-1]). </span>

<span class="sd">		epoch : int/float</span>
<span class="sd">			Time epoch (at the start of the simulation) given in MJD format (Modified Julian Date). This epoch is used to synchronize the states of the space objects</span>
<span class="sd">			with the simulation time.</span>

<span class="sd">		t_slice : float/numpy.ndarray </span>
<span class="sd">            Array of time slice durations. The duration of each time slice $T_s^i$ be less than or equal to the time step between two consecutive time slices. In other</span>
<span class="sd">            words, $t_{slice}^i &lt; t^{i+1} - t^{i}$</span>

<span class="sd">        state_per_slice (optional) : int</span>
<span class="sd">            number of tracking control points per time slice. </span>

<span class="sd">            A space object can be tracked at multiple time points within a given time slice. If state_per_slice is greater than one, then additional tracking points</span>
<span class="sd">            will be added within the time slice at regular time intervals (separated by a duration t_slice/state_per_slice).</span>

<span class="sd">		space_object_priorities (optional) : np.ndarray (int)</span>
<span class="sd">			Priority of each space object (given in the same order as space_objects array). if None, the priorities will be set automatically following the FIFO algorithm.</span>
<span class="sd">			Low numbers indicate a high tracking prioriy.</span>

<span class="sd">		priority : int (optional)</span>
<span class="sd">            Priority of the generated controls, only used by the scheduler to choose between overlapping controls. Low numbers indicate a high control prioriy. None is used for dynamic priority management algorithms.</span>

<span class="sd">		interpolator (optional) : sorts.interpolation.Interpolation</span>
<span class="sd">			Interpolation algorithm used to reconstruct interpolate target states between propagated states.</span>
<span class="sd">			If no interpolator is profided, the default interpolation class used will be sorts.interpolation.Linear </span>

<span class="sd">		max_dpos (optional) : int</span>
<span class="sd">			maximum distance in meters between two consecutive propagated states.</span>
<span class="sd">			The default value is 50km.</span>

<span class="sd">		max_samp (optional) : int</span>
<span class="sd">			maximum number of time samples used for target states propagation.</span>

<span class="sd">		max_processes (optional) : int</span>
<span class="sd">			maximum number of simultaneous processes used during the generation of the tracking schedule. The default value is 16 processes. </span>

<span class="sd">		scheduler (optional) : sorts.Scheduler </span>
<span class="sd">            scheduler instance used for scheduling time sunchromization between controls for tims slicing. </span>
<span class="sd">            Time slicing refers to the slicing of the time array into multiple subcontrol arrays (given as generator objects) to reduce memory (RAM) usage.</span>
<span class="sd">            This parameter is only useful when multiple controls are sent to a given scheduler.</span>
<span class="sd">            If the scheduler is not provided, the controller will slice the controls using the max_points parameter.</span>

<span class="sd">        max_points (optional) : int </span>
<span class="sd">            Max number of points for a given control array computed simultaneously. This number is used to limit the impact of computations over RAM</span>
<span class="sd">            Note that lowering this number might increase computation time, while increasing this number might cause problems depending on the available RAM on your machine</span>

<span class="sd">		save_states (optional) : bool </span>
<span class="sd">			If Rrue, the states of the space objects will be saved within the meta of the generated controls. (default value : False)</span>

<span class="sd">		cache_pdirs (optional) : bool</span>
<span class="sd">			If True, the pointing directions computation results will be cached within the control structure. Bear in mind that setting cache_pdirs might drasticly increase</span>
<span class="sd">			your RAM usage.</span>

<span class="sd">		Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorts.RadarControls</span>
<span class="sd">            Radar Controls to be applied to the radar to perform tracking of the the given array of space objects during the control interval t. </span>
<span class="sd">		</span>
<span class="sd">		Examples :</span>
<span class="sd">		----------</span>

<span class="sd">		To allow the tracking of multiple objects, one first needs to define the array of objects to be tracked.</span>
<span class="sd">		For example, an array of five objects can be defined as follows :</span>

<span class="sd">		&gt;&gt;&gt; # Target propagator options </span>
<span class="sd">		&gt;&gt;&gt; Prop_cls = sorts.Kepler</span>
<span class="sd">		&gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">		&gt;&gt;&gt;     settings = dict(</span>
<span class="sd">		&gt;&gt;&gt;         out_frame=&#39;ITRS&#39;,</span>
<span class="sd">		&gt;&gt;&gt;         in_frame=&#39;TEME&#39;,</span>
<span class="sd">		&gt;&gt;&gt;     ),</span>
<span class="sd">		&gt;&gt;&gt; )</span>

<span class="sd">		&gt;&gt;&gt; # define objects&#39; orbital parameters</span>
<span class="sd">		&gt;&gt;&gt; orbits_a = np.array([7200, 7200, 8500, 12000, 10000])*1e3 # semi major axis - m</span>
<span class="sd">		&gt;&gt;&gt; orbits_i = np.array([80, 80, 105, 105, 80]) # inclination - deg</span>
<span class="sd">		&gt;&gt;&gt; orbits_raan = np.array([86, 86, 160, 180, 90]) # right ascension of ascending node - deg</span>
<span class="sd">		&gt;&gt;&gt; orbits_aop = np.array([0, 0, 50, 40, 55]) # argument of perigee - deg</span>
<span class="sd">		&gt;&gt;&gt; orbits_mu0 = np.array([60, 50, 5, 30, 8]) # mean anomaly - deg</span>

<span class="sd">		&gt;&gt;&gt; # Initialization of each space object</span>
<span class="sd">		&gt;&gt;&gt; space_objects = []</span>
<span class="sd">		&gt;&gt;&gt; for so_id in range(len(orbits_a)):</span>
<span class="sd">		&gt;&gt;&gt;     space_objects.append(sorts.SpaceObject(</span>
<span class="sd">		&gt;&gt;&gt;             Prop_cls,</span>
<span class="sd">		&gt;&gt;&gt;             propagator_options = Prop_opts,</span>
<span class="sd">		&gt;&gt;&gt;             a = orbits_a[so_id], </span>
<span class="sd">		&gt;&gt;&gt;             e = 0.1,</span>
<span class="sd">		&gt;&gt;&gt;             i = orbits_i[so_id],</span>
<span class="sd">		&gt;&gt;&gt;             raan = orbits_raan[so_id],</span>
<span class="sd">		&gt;&gt;&gt;             aop = orbits_aop[so_id],</span>
<span class="sd">		&gt;&gt;&gt;             mu0 = orbits_mu0[so_id],</span>
<span class="sd">		&gt;&gt;&gt;             </span>
<span class="sd">		&gt;&gt;&gt;             epoch = epoch,</span>
<span class="sd">		&gt;&gt;&gt;             parameters = dict(</span>
<span class="sd">		&gt;&gt;&gt;                 d = 0.1,</span>
<span class="sd">		&gt;&gt;&gt;            ),</span>
<span class="sd">		&gt;&gt;&gt;         ))</span>

<span class="sd">		When space objects are created, one has to define a tracking priority for each one of them. The lower the scalar for the tracking priority is for a given object,</span>
<span class="sd">		the more importance will be given by the scheduler to the observation of this object.</span>

<span class="sd">		&gt;&gt;&gt; priority = np.array([3, 2, 0, 1, 4]) # observational priority associated to each object</span>
<span class="sd">		</span>
<span class="sd">		Then, we can initialize the scheduler :</span>

<span class="sd">		&gt;&gt;&gt; so_tracking_controller = sorts.SpaceObjectTracking(logger=logger, profiler=p)</span>
<span class="sd">		</span>
<span class="sd">		Finally, after defining the radar and the tracking time points, one can generate the tracking schedule :</span>

<span class="sd">		&gt;&gt;&gt; radar = instances.eiscat3d # definition of the radar instance used to track the objects</span>

<span class="sd">		&gt;&gt;&gt; # definition of tracking time points</span>
<span class="sd">		&gt;&gt;&gt; t_start = 0</span>
<span class="sd">		&gt;&gt;&gt; t_end = 100000</span>
<span class="sd">		&gt;&gt;&gt; t_slice = 0.1</span>
<span class="sd">		&gt;&gt;&gt; states_per_slice = 1</span>
<span class="sd">		&gt;&gt;&gt; epoch = 53005.0</span>
<span class="sd">		&gt;&gt;&gt; t_tracking = np.arange(t_start, t_end, tracking_period)</span>

<span class="sd">		&gt;&gt;&gt; # generation of the tracking points in the ECEF frame</span>
<span class="sd">		&gt;&gt;&gt; controls = so_tracking_controller.generate_controls(t_tracking, radar, space_objects, epoch, t_slice, states_per_slice, priority=priority)</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="c1"># check the validity of the input values</span>
		<span class="n">space_objects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">space_objects</span><span class="p">)</span> <span class="c1"># if list, convert space_objects to a numpy array</span>

		<span class="n">n_space_objects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">space_objects</span><span class="p">)</span>
		<span class="n">space_object_priorities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_space_object_priorities</span><span class="p">(</span><span class="n">space_object_priorities</span><span class="p">,</span> <span class="n">n_space_objects</span><span class="p">)</span>

		<span class="c1"># check/initialize interpolator</span>
		<span class="k">if</span> <span class="n">interpolator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule -&gt; no interpolator information provided, using interpolator.Linear&quot;</span><span class="p">)</span>
			<span class="n">interpolator</span> <span class="o">=</span> <span class="n">interpolation</span><span class="o">.</span><span class="n">Linear</span>

		<span class="c1"># check/initialize epoch</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
			<span class="n">epoch</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;mjd&#39;</span><span class="p">)</span>

		<span class="c1"># check time array </span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t must be an array&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">profiler</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule&quot;</span><span class="p">)</span>

		<span class="n">n_control_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

		<span class="c1"># create the output arrays as shared arrays</span>
		<span class="c1"># Those arrays are shared between all processes</span>
		<span class="c1"># each process will updated the array values to get the final tracking states </span>
		<span class="n">mp_shared_final_states</span> 		<span class="o">=</span> <span class="n">mptools</span><span class="o">.</span><span class="n">convert_to_shared_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="n">n_control_points</span><span class="o">*</span><span class="n">states_per_slice</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)</span>
		<span class="n">mp_shared_state_priorities</span> 	<span class="o">=</span> <span class="n">mptools</span><span class="o">.</span><span class="n">convert_to_shared_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_control_points</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">)</span>
		<span class="n">mp_shared_object_indices</span> 	<span class="o">=</span> <span class="n">mptools</span><span class="o">.</span><span class="n">convert_to_shared_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_control_points</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">)</span>

		<span class="c1"># create final output arrays from the memory slots of the shared arrays</span>
		<span class="n">final_states</span> 				<span class="o">=</span> <span class="n">mptools</span><span class="o">.</span><span class="n">convert_to_numpy_array</span><span class="p">(</span><span class="n">mp_shared_final_states</span><span class="p">,</span> 		<span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">n_control_points</span><span class="o">*</span><span class="n">states_per_slice</span><span class="p">))</span>
		<span class="n">state_priorities</span> 			<span class="o">=</span> <span class="n">mptools</span><span class="o">.</span><span class="n">convert_to_numpy_array</span><span class="p">(</span><span class="n">mp_shared_state_priorities</span><span class="p">,</span> 	<span class="p">(</span><span class="n">n_control_points</span><span class="p">,))</span>
		<span class="n">object_indices</span> 				<span class="o">=</span> <span class="n">mptools</span><span class="o">.</span><span class="n">convert_to_numpy_array</span><span class="p">(</span><span class="n">mp_shared_object_indices</span><span class="p">,</span> 		<span class="p">(</span><span class="n">n_control_points</span><span class="p">,))</span>


		<span class="c1"># generate tracking time array (adding itermediate time points to reach states_per_slice)</span>
		<span class="n">dt_tracking</span> <span class="o">=</span> <span class="n">t_slice</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">states_per_slice</span><span class="p">)</span>

		<span class="n">final_t_tracking</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">states_per_slice</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">states_per_slice</span><span class="p">):</span>
			<span class="n">final_t_tracking</span><span class="p">[</span><span class="n">ti</span><span class="p">::</span><span class="n">states_per_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_t_tracking</span><span class="p">[</span><span class="n">ti</span><span class="p">::</span><span class="n">states_per_slice</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt_tracking</span><span class="o">*</span><span class="n">ti</span>


		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TrackingScheduler:generate_schedule -&gt; Starting multiprocessing computations&quot;</span><span class="p">)</span> 

		<span class="c1"># function used to create each subprocess </span>
		<span class="k">def</span> <span class="nf">schedule_tracking</span><span class="p">(</span><span class="n">space_object_index</span><span class="p">,</span> <span class="n">mutex</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">compute_tracking_states</span><span class="p">(</span>
				<span class="n">t</span><span class="p">,</span> 
				<span class="n">t_slice</span><span class="p">,</span> 
				<span class="n">states_per_slice</span><span class="p">,</span>
				<span class="n">final_t_tracking</span><span class="p">,</span> 
				<span class="n">space_objects</span><span class="p">[</span><span class="n">space_object_index</span><span class="p">],</span> 
				<span class="n">space_object_index</span><span class="p">,</span> 
				<span class="n">radar</span><span class="p">,</span> 
				<span class="n">epoch</span><span class="p">,</span> 
				<span class="n">space_object_priorities</span><span class="p">[</span><span class="n">space_object_index</span><span class="p">],</span> 
				<span class="n">interpolator</span><span class="p">,</span> 
				<span class="n">max_dpos</span><span class="p">,</span>
				<span class="n">max_samp</span><span class="p">,</span> 
				<span class="n">mp_shared_final_states</span><span class="p">,</span> 
				<span class="n">mp_shared_state_priorities</span><span class="p">,</span> 
				<span class="n">mp_shared_object_indices</span><span class="p">,</span> 
				<span class="n">mutex</span>
			<span class="p">)</span>

		<span class="c1"># subgroup of processes (size max_processes) will be created to propagate and find the states to track for each space object</span>
		<span class="k">for</span> <span class="n">process_subgroup_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">space_objects</span><span class="p">)</span><span class="o">/</span><span class="n">max_processes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
			<span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">space_objects</span><span class="p">)</span> <span class="o">-</span> <span class="n">process_subgroup_id</span><span class="o">*</span><span class="n">max_processes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max_processes</span><span class="p">:</span>
				<span class="n">n_process_in_subgroup</span> <span class="o">=</span> <span class="n">max_processes</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">n_process_in_subgroup</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">space_objects</span><span class="p">)</span> <span class="o">-</span> <span class="n">process_subgroup_id</span><span class="o">*</span><span class="n">max_processes</span><span class="p">)</span>

			<span class="n">mutex</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c1"># create the mp.Lock mutex to ensure critical ressources sync between processes</span>
			<span class="n">process_subgroup</span> <span class="o">=</span> <span class="p">[]</span>

			<span class="c1"># initializes each process and associate them to an object in the list of targets to follow</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_process_in_subgroup</span><span class="p">):</span>
				<span class="n">so_id</span> <span class="o">=</span> <span class="n">process_subgroup_id</span> <span class="o">*</span> <span class="n">max_processes</span> <span class="o">+</span> <span class="n">i</span> <span class="c1"># get the object&#39;s id</span>
				<span class="n">process</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">schedule_tracking</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">so_id</span><span class="p">,</span> <span class="n">mutex</span><span class="p">,))</span> <span class="c1"># create new process</span>

				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
					<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TrackingScheduler:generate_schedule -&gt; (process pid </span><span class="si">{</span><span class="n">mptools</span><span class="o">.</span><span class="n">get_process_id</span><span class="p">()</span><span class="si">}</span><span class="s2">) creating subprocess id </span><span class="si">{</span><span class="n">so_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 

				<span class="n">process_subgroup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
				<span class="n">process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

			<span class="c1"># wait for each process to be finished</span>
			<span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">process_subgroup</span><span class="p">:</span>
				<span class="n">process</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

		<span class="c1"># check if there are some empty spots in the target states array and removes them</span>
		<span class="n">ctrl_msk</span> <span class="o">=</span> <span class="n">state_priorities</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="n">state_msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ctrl_msk</span><span class="p">,</span> <span class="n">states_per_slice</span><span class="p">)</span>

		<span class="c1"># creating output tracking controls</span>
		<span class="n">controls</span> <span class="o">=</span> <span class="n">radar_controls</span><span class="o">.</span><span class="n">RadarControls</span><span class="p">(</span><span class="n">radar</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">=</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="n">priority</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span> <span class="n">profiler</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">profiler</span><span class="p">)</span>  <span class="c1"># the controls structure is defined as a dictionnary of subcontrols</span>
		<span class="n">controls</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;interpolator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolator</span>

		<span class="n">controls</span><span class="o">.</span><span class="n">set_time_slices</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">ctrl_msk</span><span class="p">],</span> <span class="n">t_slice</span><span class="p">,</span> <span class="n">max_points</span><span class="o">=</span><span class="n">max_points</span><span class="p">)</span>

		<span class="n">final_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">final_states</span><span class="p">[:,</span> <span class="n">state_msk</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">states_per_slice</span><span class="o">*</span><span class="n">controls</span><span class="o">.</span><span class="n">splitting_indices</span><span class="p">)</span>
		<span class="n">final_t_tracking</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">final_t_tracking</span><span class="p">[</span><span class="n">state_msk</span><span class="p">],</span> <span class="n">states_per_slice</span><span class="o">*</span><span class="n">controls</span><span class="o">.</span><span class="n">splitting_indices</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">profiler</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule&quot;</span><span class="p">)</span>

		<span class="c1"># Compute controls</span>
		<span class="n">pdir_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">final_states</span><span class="p">,</span> <span class="n">final_t_tracking</span><span class="p">)</span>
		<span class="n">controls</span><span class="o">.</span><span class="n">set_pdirs</span><span class="p">(</span><span class="n">pdir_args</span><span class="p">,</span> <span class="n">cache_pdirs</span><span class="o">=</span><span class="n">cache_pdirs</span><span class="p">)</span>

		<span class="n">radar_controller</span><span class="o">.</span><span class="n">RadarController</span><span class="o">.</span><span class="n">coh_integration</span><span class="p">(</span><span class="n">controls</span><span class="p">,</span> <span class="n">radar</span><span class="p">,</span> <span class="n">t_slice</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">save_states</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
			<span class="n">controls</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;object_indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">object_indices</span><span class="p">[</span><span class="n">ctrl_msk</span><span class="p">]</span>
			<span class="n">controls</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;state_priorities&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_priorities</span><span class="p">[</span><span class="n">ctrl_msk</span><span class="p">]</span>
			<span class="n">controls</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;space_objects_states&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_states</span>

		<span class="k">return</span> <span class="n">controls</span></div>

<div class="viewcode-block" id="SpaceObjectTracker.compute_tracking_states"><a class="viewcode-back" href="../../../../reference/controllers/auto/sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.compute_tracking_states.html#sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.compute_tracking_states">[docs]</a>	<span class="k">def</span> <span class="nf">compute_tracking_states</span><span class="p">(</span>
		<span class="bp">self</span><span class="p">,</span> 
		<span class="n">t_controller</span><span class="p">,</span> 
		<span class="n">t_slice</span><span class="p">,</span>
		<span class="n">states_per_slice</span><span class="p">,</span>
		<span class="n">final_t_tracking</span><span class="p">,</span> 
		<span class="n">space_object</span><span class="p">,</span> 
		<span class="n">space_object_index</span><span class="p">,</span> 
		<span class="n">radar</span><span class="p">,</span> 
		<span class="n">epoch</span><span class="p">,</span> 
		<span class="n">space_object_priority</span><span class="p">,</span> 
		<span class="n">interpolator</span><span class="p">,</span> 
		<span class="n">max_dpos</span><span class="p">,</span> 
		<span class="n">max_samp</span><span class="p">,</span> 
		<span class="n">final_states_shared</span><span class="p">,</span> 
		<span class="n">state_priorities_shared</span><span class="p">,</span> 
		<span class="n">object_indices_shared</span><span class="p">,</span> 
		<span class="n">mutex</span>
	<span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">		Process subroutine used to gather the states of one of the object to follow. After computing the states, this function will add the states which satify the set of constraints to the schedule.</span>

<span class="sd">		First, the algorithm computes the states of the given space object over the entirety of the control time interval. Then, it performs a data reduction procedure by only keeping the states which </span>
<span class="sd">		are within the field of view of all the stations. Then, the algorithm will compare the priorities of the previous pointing direction controls and will overwrite the ones with a lower priority </span>
<span class="sd">		compared to the current space object. Finally, the algorithm will performs an interpolation to compute the states at each time point where a tracking pointing direction control will be applied </span>
<span class="sd">		(states_per_slice pointing directions will be performed during each time slice).</span>
<span class="sd">		</span>
<span class="sd">		Parameters :</span>
<span class="sd">		------------ </span>
<span class="sd">			t_controller : np.ndarray (N,)</span>
<span class="sd">				Starting point of each time slice of the controller (in seconds). </span>

<span class="sd">			t_slice : float</span>
<span class="sd">				Duration of each time slice of the controller (in seconds). </span>

<span class="sd">			space_object : sorts.SpaceObject</span>
<span class="sd">				Space object instance which states we wish to propagate in time.</span>

<span class="sd">			states_per_slice : int</span>
<span class="sd">				numver of pointing directions controls per time slice. If this number is greater than one, the algorithm will create &quot;states_per_slice&quot; pointing direction controls per time slice which </span>
<span class="sd">				separated by a constant time interval of dt = t_slice/states_per_slice</span>
<span class="sd">			</span>
<span class="sd">			final_t_tracking : np.ndarray (M,)</span>
<span class="sd">				Array containing the instants at which a pointing direction control will be performed to track a set of space objects.</span>
<span class="sd">		</span>
<span class="sd">			space_object : sorts.SpaceObject</span>
<span class="sd">				one of the space object to be tracked by the controller.</span>

<span class="sd">			space_object_index : np.ndarray (M,)</span>
<span class="sd">				index of the space object to be tracked by the controller inside the population of objects to considered by the controller.</span>

<span class="sd">			radar : sorts.Radar</span>
<span class="sd">				Radar instance controlled by the controller.</span>

<span class="sd">			epoch : float</span>
<span class="sd">				epoch at which the propagation/computations are performed. The epoch must be specified in MJD format</span>

<span class="sd">			space_object_priority : int</span>
<span class="sd">				priority of the current space object. The priority is used to choose which space object to track when multiple space objects are within the field of view of the radar. In this case, the object of </span>
<span class="sd">				highest priority (i.e. space_object_priority is the lowest number of all) at a given instant will be the one being tracked. </span>

<span class="sd">			interpolator : interpolation.Interpolator</span>
<span class="sd">				interpolator instance used to interpolate between states (see sorts.Linear or sorts.Lagrange8 for more information on how to use the interpolators)</span>

<span class="sd">			max_dpos : float</span>
<span class="sd">				maximum distance between two consecutive states when the equidistant sampling method is used when computing the space object states. This sampling method is used when the state of the object</span>
<span class="sd">				(retreivable by calling space_object.state) is given as a pyorb.Orbit instance.</span>

<span class="sd">			max_samp : int </span>
<span class="sd">				maximum number of time points in the array when the constant time sampling method is used when computing the space object states. This sampling method is used when the state of the object</span>
<span class="sd">				(retreivable by calling space_object.state) is NOT given as a pyorb.Orbit instance, but for example as (6,1) vector.</span>
<span class="sd">	</span>
<span class="sd">			final_states_shared, : multiprocessing.Array (6, M)</span>
<span class="sd">				Array (shared between processes) containing the states of the different space objects (ECEF coordinate frame) for each pointing direction control points. </span>

<span class="sd">			state_priorities_shared : multiprocessing.Array (N,)</span>
<span class="sd">				Array (shared between processes) containing the priorities of each pointing direction control points. The priority of a given pointing direction control points correspond to the priority of</span>
<span class="sd">				the space object being tracked at this instant. </span>

<span class="sd">			object_indices_shared : multiprocessing.Array (N,)</span>
<span class="sd">				Array (shared between processes) containing the space object id being tracked at each pointing direction control points. </span>

<span class="sd">			mutex : processing.Lock</span>
<span class="sd">				Mutex instance used for synchronization between processes</span>


<span class="sd">		Returns : </span>
<span class="sd">		---------</span>
<span class="sd">			None</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TrackingScheduler:generate_schedule -&gt; (subprocess pid </span><span class="si">{</span><span class="n">mptools</span><span class="o">.</span><span class="n">get_process_id</span><span class="p">()</span><span class="si">}</span><span class="s2">) object </span><span class="si">{</span><span class="n">space_object_index</span><span class="si">}</span><span class="s2"> starting&quot;</span><span class="p">)</span>

		<span class="c1"># get epoch correction time </span>
		<span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">space_object</span><span class="o">.</span><span class="n">epoch</span> <span class="o">-</span> <span class="n">epoch</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="s2">&quot;sec&quot;</span><span class="p">)</span>

		<span class="c1"># compute and interpolate target states </span>
		<span class="n">t_states</span><span class="p">,</span> <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states</span><span class="p">(</span><span class="n">t_controller</span> <span class="o">-</span> <span class="n">dt</span><span class="p">,</span> <span class="n">t_slice</span><span class="p">,</span> <span class="n">space_object</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">max_dpos</span><span class="p">,</span> <span class="n">max_samp</span><span class="p">)</span> <span class="c1"># propagates the target states</span>
		<span class="n">state_interpolator</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">t_states</span><span class="p">)</span> <span class="c1"># intitializes the interpolation object associated with those states</span>

		<span class="c1"># find simultaneous passes for all stations </span>
		<span class="n">passes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_passes</span><span class="p">(</span><span class="n">t_states</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">radar</span><span class="p">)</span>
		<span class="k">del</span> <span class="n">states</span>

		<span class="c1"># check if there are conflicts with existing final tracking states and modifies the schedule</span>
		<span class="k">for</span> <span class="n">pass_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">passes</span><span class="p">)):</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
				<span class="bp">self</span><span class="o">.</span><span class="n">profiler</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule:extract_states&quot;</span><span class="p">)</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
				<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TrackingScheduler:generate_schedule -&gt; (subprocess pid </span><span class="si">{</span><span class="n">mptools</span><span class="o">.</span><span class="n">get_process_id</span><span class="p">()</span><span class="si">}</span><span class="s2">) Extracting states for radar pass </span><span class="si">{</span><span class="n">pass_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TrackingScheduler:generate_schedule -&gt; (subprocess pid </span><span class="si">{</span><span class="n">mptools</span><span class="o">.</span><span class="n">get_process_id</span><span class="p">()</span><span class="si">}</span><span class="s2">) Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">passes</span><span class="p">[</span><span class="n">pass_id</span><span class="p">]</span><span class="o">.</span><span class="n">inds</span><span class="p">)</span><span class="si">}</span><span class="s2"> time points&quot;</span><span class="p">)</span>

			<span class="c1"># get shared memory priority array</span>
			<span class="n">state_priorities</span> 	<span class="o">=</span> <span class="n">mptools</span><span class="o">.</span><span class="n">convert_to_numpy_array</span><span class="p">(</span><span class="n">state_priorities_shared</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_controller</span><span class="p">),))</span>

			<span class="c1"># get states in the pass which satisfy the constraints (priority is greater than already scheduled observations (or free obs. slot available) and the controller time slice is inside the pass time interval) </span>
			<span class="n">pass_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">t_controller</span> <span class="o">&gt;=</span> <span class="n">t_states</span><span class="p">[</span><span class="n">passes</span><span class="p">[</span><span class="n">pass_id</span><span class="p">]</span><span class="o">.</span><span class="n">inds</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_controller</span> <span class="o">&lt;=</span> <span class="n">t_states</span><span class="p">[</span><span class="n">passes</span><span class="p">[</span><span class="n">pass_id</span><span class="p">]</span><span class="o">.</span><span class="n">inds</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_slice</span><span class="p">)</span>	<span class="c1"># remove control points outside of the pass</span>
			<span class="k">del</span> <span class="n">t_states</span>

			<span class="n">priority_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">state_priorities</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">state_priorities</span> <span class="o">&gt;</span> <span class="n">space_object_priority</span><span class="p">)</span>	<span class="c1"># remove points where there is already a higher priority observation</span>

			<span class="n">ctrl_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">pass_mask</span><span class="p">,</span> <span class="n">priority_mask</span><span class="p">)</span> <span class="c1"># compute intersection of priority constraint and observational constraints</span>
			<span class="n">state_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ctrl_mask</span><span class="p">,</span> <span class="n">states_per_slice</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">priority_mask</span><span class="p">,</span> <span class="n">pass_mask</span>
			
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
				<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TrackingScheduler:generate_schedule -&gt; (subprocess pid </span><span class="si">{</span><span class="n">mptools</span><span class="o">.</span><span class="n">get_process_id</span><span class="p">()</span><span class="si">}</span><span class="s2">) saving </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">state_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2"> states&quot;</span><span class="p">)</span>

			<span class="c1"># get remaining arrays from shared process memory</span>
			<span class="n">final_states</span> 		<span class="o">=</span> <span class="n">mptools</span><span class="o">.</span><span class="n">convert_to_numpy_array</span><span class="p">(</span><span class="n">final_states_shared</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_controller</span><span class="p">)</span><span class="o">*</span><span class="n">states_per_slice</span><span class="p">))</span>
			<span class="n">object_indices</span> 		<span class="o">=</span> <span class="n">mptools</span><span class="o">.</span><span class="n">convert_to_numpy_array</span><span class="p">(</span><span class="n">object_indices_shared</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_controller</span><span class="p">),))</span>

			<span class="c1"># modify the tracking schedule where constraints are statisfied </span>
			<span class="n">mutex</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
			<span class="n">final_states</span><span class="p">[:,</span> <span class="n">state_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_interpolator</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span><span class="n">final_t_tracking</span><span class="p">[</span><span class="n">state_mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span>
			<span class="n">state_priorities</span><span class="p">[</span><span class="n">ctrl_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">space_object_priority</span>
			<span class="n">object_indices</span><span class="p">[</span><span class="n">ctrl_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">space_object_index</span>
			<span class="n">mutex</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
				<span class="bp">self</span><span class="o">.</span><span class="n">profiler</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule:extract_states&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="SpaceObjectTracker.get_states"><a class="viewcode-back" href="../../../../reference/controllers/auto/sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.get_states.html#sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.get_states">[docs]</a>	<span class="k">def</span> <span class="nf">get_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t_slice</span><span class="p">,</span> <span class="n">space_object</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">max_dpos</span><span class="p">,</span> <span class="n">max_samp</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">		Computes the ecef states $\vec{x} = [x, y, z, vx, vy, vz]^{T}$ of the given space object over the control time interval given by t and t_slice.</span>

<span class="sd">		Parameters :</span>
<span class="sd">		------------ </span>
<span class="sd">			t : np.ndarray (N,)</span>
<span class="sd">				Starting point of each time slice of the controller (in seconds). </span>

<span class="sd">			t_slice : float</span>
<span class="sd">				Duration of each time slice of the controller (in seconds). </span>

<span class="sd">			space_object : sorts.SpaceObject</span>
<span class="sd">				Space object instance which states we wish to propagate in time.</span>

<span class="sd">			max_dpos : float</span>
<span class="sd">				maximum distance between two consecutive states when the equidistant sampling method is used (1st method).</span>

<span class="sd">			max_samp : int </span>
<span class="sd">				maximum number of time points in the array when the constant time sampling method is used (2nd method).</span>

<span class="sd">		Returns : </span>
<span class="sd">		---------</span>
<span class="sd">			np.ndarray (6, M)</span>
<span class="sd">				propagated states of the space object over the given control time interval.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">t_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sampling_time</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t_slice</span><span class="p">,</span> <span class="n">space_object</span><span class="p">,</span> <span class="n">max_dpos</span><span class="p">,</span> <span class="n">max_samp</span><span class="p">)</span>

		<span class="c1"># propagates the object&#39;s states </span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule:get_states&quot;</span><span class="p">)</span>	
		<span class="n">states</span> <span class="o">=</span> <span class="n">space_object</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span><span class="n">t_states</span><span class="p">)</span>		
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule:get_states&quot;</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">t_states</span><span class="p">,</span> <span class="n">states</span></div>



<div class="viewcode-block" id="SpaceObjectTracker.get_sampling_time"><a class="viewcode-back" href="../../../../reference/controllers/auto/sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.get_sampling_time.html#sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.get_sampling_time">[docs]</a>	<span class="k">def</span> <span class="nf">get_sampling_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t_slice</span><span class="p">,</span> <span class="n">space_object</span><span class="p">,</span> <span class="n">max_dpos</span><span class="p">,</span> <span class="n">max_samp</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		This function returns the array of sampling time points needed to propagate the states of a given space object. </span>

<span class="sd">		There are two possible ways to generate sampling time arrays :</span>
<span class="sd">			1. When the states of the space objects are given as a pyorb.Orbit instance, the time points are generated to ensure that the distance between two consecutive states on the orbit stays constant. </span>
<span class="sd">			2. If the states of the space object are not given as a pyorb.Orbit instance, the time points are instead generated to ensure that the time interval between two consecutive states stays constant.</span>

<span class="sd">		Parameters :</span>
<span class="sd">		------------ </span>
<span class="sd">			t : np.ndarray (N,)</span>
<span class="sd">				Starting point of each time slice of the controller (in seconds). </span>

<span class="sd">			t_slice : float</span>
<span class="sd">				Duration of each time slice of the controller (in seconds). </span>

<span class="sd">			space_object : sorts.SpaceObject</span>
<span class="sd">				Space object instance which states we wish to propagate in time.</span>

<span class="sd">			max_dpos : float</span>
<span class="sd">				maximum distance between two consecutive states when the equidistant sampling method is used (1st method).</span>

<span class="sd">			max_samp : int </span>
<span class="sd">				maximum number of time points in the array when the constant time sampling method is used (2nd method).</span>

<span class="sd">		Returns : </span>
<span class="sd">		---------</span>
<span class="sd">			np.ndarray (M,)</span>
<span class="sd">				state sampling time array of the given space object </span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TrackingScheduler:generate_schedule -&gt; (subprocess pid </span><span class="si">{</span><span class="n">mptools</span><span class="o">.</span><span class="n">get_process_id</span><span class="p">()</span><span class="si">}</span><span class="s2">) generating state time array&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		 	<span class="bp">self</span><span class="o">.</span><span class="n">profiler</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule:create_sampling_time_array&quot;</span><span class="p">)</span>

		<span class="c1"># generate states propagation time points  </span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_object</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">pyorb</span><span class="o">.</span><span class="n">Orbit</span><span class="p">):</span> <span class="c1"># by finding spatially equidistant time points</span>
			<span class="n">t_states</span> <span class="o">=</span> <span class="n">equidistant_sampling</span><span class="p">(</span>
				<span class="n">orbit</span> <span class="o">=</span> <span class="n">space_object</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> 
				<span class="n">start_t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
				<span class="n">end_t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_slice</span><span class="p">,</span> 
				<span class="n">max_dpos</span> <span class="o">=</span> <span class="n">max_dpos</span><span class="p">,</span>
			<span class="p">)</span>
		<span class="k">else</span><span class="p">:</span> <span class="c1"># or by finding temporally equidistant time points</span>
			<span class="n">t_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_slice</span><span class="p">,</span> <span class="n">max_samp</span><span class="p">)</span>		

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">profiler</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule:create_sampling_time_array&quot;</span><span class="p">)</span>	

		<span class="k">return</span> <span class="n">t_states</span></div>



<div class="viewcode-block" id="SpaceObjectTracker.get_passes"><a class="viewcode-back" href="../../../../reference/controllers/auto/sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.get_passes.html#sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.get_passes">[docs]</a>	<span class="k">def</span> <span class="nf">get_passes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_states</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">radar</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">		Finds the passes which are simultaneously in the FOV of all the radar stations. </span>

<span class="sd">		Parameters :</span>
<span class="sd">		------------</span>
<span class="sd">			t_states : np.ndarray (N,)</span>
<span class="sd">				this array contains the time points (in seconds) at which the states were propagated. It is assumed that the time values are given with respect to the space object&#39;s epoch.</span>

<span class="sd">			states : np.ndarray (6, N) </span>
<span class="sd">				This array contains the space object&#39;s states $\vec{x} = [x, y, z, vx, vy, vz]^{T}$ associated to each time point of t_states.</span>
<span class="sd">	</span>
<span class="sd">			radar : sorts.Radar</span>
<span class="sd">				radar instance over which we want to compute the space object passes.</span>

<span class="sd">		Returns :</span>
<span class="sd">		---------</span>
<span class="sd">			np.ndarray :</span>
<span class="sd">				the function returns an array of sorts.Pass objects which correspond to all the radar passes found for the given state array and radar instance.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TrackingScheduler:generate_schedule -&gt; (subprocess pid </span><span class="si">{</span><span class="n">mptools</span><span class="o">.</span><span class="n">get_process_id</span><span class="p">()</span><span class="si">}</span><span class="s2">) searching for simultaneous passes&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">profiler</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule:find_simultaneous_passes&quot;</span><span class="p">)</span>

		<span class="n">passes</span> <span class="o">=</span> <span class="n">find_simultaneous_passes</span><span class="p">(</span><span class="n">t_states</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="p">[</span><span class="o">*</span><span class="n">radar</span><span class="o">.</span><span class="n">tx</span><span class="p">,</span> <span class="o">*</span><span class="n">radar</span><span class="o">.</span><span class="n">rx</span><span class="p">])</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">profiler</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule:find_simultaneous_passes&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TrackingScheduler:generate_schedule -&gt; (subprocess pid </span><span class="si">{</span><span class="n">mptools</span><span class="o">.</span><span class="n">get_process_id</span><span class="p">()</span><span class="si">}</span><span class="s2">) found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">passes</span><span class="p">)</span><span class="si">}</span><span class="s2"> passes&quot;</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">passes</span></div>


<div class="viewcode-block" id="SpaceObjectTracker.check_space_object_priorities"><a class="viewcode-back" href="../../../../reference/controllers/auto/sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.check_space_object_priorities.html#sorts.radar.controllers.space_object_tracker.SpaceObjectTracker.check_space_object_priorities">[docs]</a>	<span class="k">def</span> <span class="nf">check_space_object_priorities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space_object_priorities</span><span class="p">,</span> <span class="n">n_space_objects</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks the validity of the space_object_priorities array. If space_object_priorities is None, the space objects priorities will be created following a </span>
<span class="sd">		FIFO algorithm.</span>

<span class="sd">		The space object priority is used to choose which space object will be tracked when multiple objects are within range at the same time.</span>

<span class="sd">		Parameters :</span>
<span class="sd">		------------</span>
<span class="sd">			space_object_priorities : np.ndarray</span>
<span class="sd">				array containing the priority of each space object.</span>

<span class="sd">			n_space_objects : int</span>
<span class="sd">				number of space objects</span>

<span class="sd">		Returns :</span>
<span class="sd">		---------</span>
<span class="sd">			np.ndarray :</span>
<span class="sd">				returns the validated/generated space object priority array.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">space_object_priorities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># if none, the priority is generated automatically following the FIFO algorithm</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
				<span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;TrackingScheduler:generate_schedule -&gt; no priority information provided, using FIFO algorithm&quot;</span><span class="p">)</span>
			
			<span class="n">space_object_priorities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_space_objects</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span> 
			<span class="c1"># if not, checks if space_object_priorities is a positive array of integers of the same size as space_objects</span>
			<span class="n">space_object_priorities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">space_object_priorities</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> 

			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">space_object_priorities</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_space_objects</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;space_object_priorities (</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">space_object_priorities</span><span class="p">)</span><span class="si">}</span><span class="s2">) must be the same size as space_objects (</span><span class="si">{</span><span class="n">n_space_objects</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

			<span class="n">neg_priority_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">space_object_priorities</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">neg_priority_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;space_object_priorities must be positive. check indices </span><span class="si">{</span><span class="n">neg_priority_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

			<span class="k">del</span> <span class="n">neg_priority_indices</span>

		<span class="k">return</span> <span class="n">space_object_priorities</span></div></div>
</pre></div>

              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright [2020-2022] Daniel Kastinen, Juha Vierinen, Thomas Maynadie.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>