
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sorts.radar.system.radar &#8212; SORTS v4.0 Manual</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "dark";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="None">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="dark">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
  
    <p class="title logo__title">SORTS v4.0 Manual</p>
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../intro.html">
  Introduction
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../install.html">
  Installation
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../usermanual.html">
  SORTS Manual
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/danielk333/sorts" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <h1>Source code for sorts.radar.system.radar</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39; </span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">passes</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">measurements</span>
<span class="kn">from</span> <span class="nn">...common</span> <span class="kn">import</span> <span class="n">interpolation</span>
<span class="kn">from</span> <span class="nn">...transformations</span> <span class="kn">import</span> <span class="n">frames</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">station</span>
<span class="kn">from</span> <span class="nn">sorts</span> <span class="kn">import</span> <span class="n">clibsorts</span>

<span class="c1"># Define C interface</span>
<span class="n">clibsorts</span><span class="o">.</span><span class="n">compute_intersection_points</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">),</span>
    <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">ndpointer</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">),</span>
    <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span>
    <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span>
    <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="Radar"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.html#sorts.radar.system.radar.Radar">[docs]</a><span class="k">class</span> <span class="nc">Radar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encapsulates a Radar system.</span>
<span class="sd">        </span>
<span class="sd">    The Radar class is used to define a Radar system (i.e. a network of :class:`TX&lt;sorts.radar.system.station.TX&gt;`</span>
<span class="sd">    /:class:`RX&lt;sorts.radar.system.station.RX&gt;` stations). It provides the used with a set of functionalities to easily </span>
<span class="sd">    access and control the properties of the stations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tx : :class:`TX&lt;sorts.radar.system.station.TX&gt;`/numpy.ndarray of :class:`TX&lt;sorts.radar.system.station.TX&gt;` radar stations</span>
<span class="sd">        Set of Transmitting radar stations.</span>
<span class="sd">    rx : :class:`RX&lt;sorts.radar.system.station.RX&gt;`/numpy.ndarray of :class:`RX&lt;sorts.radar.system.station.RX&gt;` radar stations</span>
<span class="sd">        Set of Receiving radar stations.</span>
<span class="sd">    min_SNRdb : float, optional </span>
<span class="sd">        Minimal SNR detection level (in :math:`dB`). </span>
<span class="sd">        If SNR computations are over this threshold, the measurement will be considered as a positive object detection.</span>
<span class="sd">        ``min_SNRdb`` must be a positive float.</span>
<span class="sd">        Default : 10.0 dB</span>
<span class="sd">    logger : logging.Logger instance, optional</span>
<span class="sd">        Logger instance used to log the computation status within class methods</span>
<span class="sd">        Default : None</span>
<span class="sd">    profiler : :class:`Profiler&lt;sorts.common.profiling.Profiler&gt;` instance</span>
<span class="sd">        :class:`Profiler&lt;sorts.common.profiling.Profiler&gt;` instance used to get computation time and performances wint class methods</span>
<span class="sd">        Default : None</span>
<span class="sd">    joint_stations : list of tuple</span>
<span class="sd">        list of stations indices (:class:`TX&lt;sorts.radar.system.station.TX&gt;`/:class:`RX&lt;sorts.radar.system.station.RX&gt;`) which </span>
<span class="sd">        phisically correspond to the same antenna. This is used when one antenna is use both as a receiver and transmitter.</span>
<span class="sd">        Default : None</span>
<span class="sd">    measurement : measurements.Measurement instance</span>
<span class="sd">        Measurement class instance used to simulate SNR/range/range rate measurements. See :class:`Measurements&lt;sorts.radar.measurements.base.Measurement&gt;` for</span>
<span class="sd">        more information.</span>
<span class="sd">        Default : measurements.Measurement</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        sorts.radar.controllers : defines a set of standard radar controllers to generate custom radar control sequences.</span>
<span class="sd">        sorts.radar.radar_controls.RadarControls : encapsulates a radar control sequence. </span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">TIME_VARIABLES</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;t&quot;</span><span class="p">,</span>
        <span class="s2">&quot;t_slice&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="sd">&#39;&#39;&#39; Parametrization of a radar control time slice.</span>

<span class="sd">    A radar control time slice is characterized by its start time ``t`` and its duration ``t_slice``. The array of starting points ``t`` of time slices is used </span>
<span class="sd">    throughout the library to date each control, but one has to keep in mind that the control is active from ``t`` to ``t + t_slice`` seconds.</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        Multiple controls can coexist within a single control time slice, this is for example the case of the scanning controls which can scan simultaneously multiple </span>
<span class="sd">        points. </span>

<span class="sd">    The time slice parameters are set by the controllers, which associate a set of controls for each radar station (such as pulse length, pointing direction, ...)to each time slice.</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        sorts.radar.controllers : defines a set of standard radar controllers to generate custom radar control sequences.</span>
<span class="sd">        sorts.radar.radar_controls.RadarControls : encapsulates a radar control sequence. </span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Radar.__init__"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.__init__.html#sorts.radar.system.radar.Radar.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">tx</span><span class="p">,</span> 
        <span class="n">rx</span><span class="p">,</span> 
        <span class="n">min_SNRdb</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> 
        <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
        <span class="n">profiler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
        <span class="n">joint_stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
        <span class="n">measurement</span><span class="o">=</span><span class="n">measurements</span><span class="o">.</span><span class="n">Measurement</span>
    <span class="p">):</span> 
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Default class constructor.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span>
        <span class="sd">&#39;&#39;&#39; List of transmitting stations in the network. &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rx</span> <span class="o">=</span> <span class="n">rx</span>
        <span class="sd">&#39;&#39;&#39; List of receiving stations in the network. &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="sd">&#39;&#39;&#39; logging.Logger instance used keep track of the computation status. &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">profiler</span> <span class="o">=</span> <span class="n">profiler</span>
        <span class="sd">&#39;&#39;&#39; :class:`Profiling&lt;sorts.common.profiling.Profiler&gt; instance used to evaluate the computing performances of the library. &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_SNRdb</span> <span class="o">=</span> <span class="n">min_SNRdb</span>
        <span class="sd">&#39;&#39;&#39; .. _minsnrdb</span>

<span class="sd">        logging.Logger instance used keep track of the computation status &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">measurement_class</span> <span class="o">=</span> <span class="n">measurement</span><span class="p">(</span><span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">profiler</span><span class="o">=</span><span class="n">profiler</span><span class="p">)</span>
        <span class="sd">&#39;&#39;&#39; :class:`Measurement&lt;sorts.radar.measurements.base.Measurement&gt;` instance used simulate radar measurements (SNR, Range, ...). &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&#39;&#39;&#39; dict containing the radar states if cached. &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">joint_stations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&#39;&#39;&#39; list of stations indices (:class:`TX&lt;sorts.radar.system.station.TX&gt;`/:class:`RX&lt;sorts.radar.system.station.RX&gt;`) which </span>
<span class="sd">            phisically correspond to the same antenna. &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="n">joint_stations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">joint_stations</span> <span class="o">=</span> <span class="n">joint_stations</span></div>


<div class="viewcode-block" id="Radar.copy"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.copy.html#sorts.radar.system.radar.Radar.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Creates a deep copy of the radar system.</span>

<span class="sd">        This method is used to easily perform a deepcopy (a deepcopy performes a copy of the object itself instead of returning a reference</span>
<span class="sd">        to the object to copy) of all the attributes of a radar instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Creating a radar object by using the ``=`` symbole will copy the `reference` of the initial object (i.e. its memory adress)</span>

<span class="sd">        &gt;&gt;&gt; import sorts</span>
<span class="sd">        &gt;&gt;&gt; radar = sorts.radars.eiscat3d</span>
<span class="sd">        &gt;&gt;&gt; radar</span>
<span class="sd">        &lt;sorts.radar.system.radar.Radar object at 0x7f593a4b6df0&gt;</span>
<span class="sd">        &gt;&gt;&gt; radar_ref_copy = radar</span>
<span class="sd">        &gt;&gt;&gt; radar_ref_copy</span>
<span class="sd">        &lt;sorts.radar.system.radar.Radar object at 0x7f593a4b6df0&gt;</span>
<span class="sd">        </span>
<span class="sd">        This means that the new &#39;copy&#39; will be linked to the object of reference (which in our case is ``radar``).</span>
<span class="sd">        If we want to copy every attribute of ``radar`` in a new object with a different memory adress, we instead</span>
<span class="sd">        need to call :</span>

<span class="sd">        &gt;&gt;&gt; radar_copy = radar.copy()</span>
<span class="sd">        &gt;&gt;&gt; radar_copy</span>
<span class="sd">        &lt;sorts.radar.system.radar.Radar object at 0x7f591ae978e0&gt;</span>
<span class="sd">        </span>
<span class="sd">        Note that the newly created radar instance does not share the memory with the first object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">            copy.copy : helper module to define custom copy() methods for complex objects.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">Radar</span><span class="p">(</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="p">[],</span>
            <span class="n">rx</span> <span class="o">=</span> <span class="p">[],</span>
            <span class="n">min_SNRdb</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_SNRdb</span><span class="p">),</span>
            <span class="n">joint_stations</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joint_stations</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">tx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">tx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tx</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">rx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rx</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Radar.get_station_id"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.get_station_id.html#sorts.radar.system.radar.Radar.get_station_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_station_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Gets the station index inside the network.</span>

<span class="sd">        The ``get_station_id`` method gets the index of a given radar station inside the ``tx``/``rx`` lists containing</span>
<span class="sd">        all the stations of the network.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        station : sorts.radar.system.station.Station </span>
<span class="sd">            Station instance within the radar network which index we want to know.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int </span>
<span class="sd">            Station id inside the network.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception :</span>
<span class="sd">            if the station instance is not part of the radar network.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The index of the station corresponds to the index of the station inside the ``tx`` or ``rx`` arrays, which </span>
<span class="sd">            means that we can&#39;t know the type of station from the value returned by the function.</span>

<span class="sd">            Therefore, one needs to keep track of the station type when calling the ``get_station_id`` method.</span>
<span class="sd">    </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        For the sake of the example, let&#39;s first create a station instance which will correspond to the station of type ``rx``</span>
<span class="sd">        of index 1:</span>

<span class="sd">        &gt;&gt;&gt; import sorts</span>
<span class="sd">        &gt;&gt;&gt; radar = sorts.radars.eiscat3d</span>
<span class="sd">        &gt;&gt;&gt; station = radar.rx[1]</span>
<span class="sd">        &gt;&gt;&gt; station</span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7f591ae998c0&gt;</span>

<span class="sd">        If we want to know the index of the station, one simply needs to call :</span>

<span class="sd">        &gt;&gt;&gt; radar.get_station_id(station)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; radar.rx[radar.get_station_id(station)]</span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7f591ae998c0&gt;</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">station_id</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># get type and id of station</span>
        <span class="k">for</span> <span class="n">station_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;rx&quot;</span><span class="p">,</span> <span class="s2">&quot;tx&quot;</span><span class="p">):</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_type</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sid</span><span class="p">,</span> <span class="n">station_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stations</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">station_</span> <span class="o">==</span> <span class="n">station</span><span class="p">:</span>
                    <span class="n">station_id</span> <span class="o">=</span> <span class="n">sid</span>
                    <span class="k">break</span>
        
        <span class="k">if</span> <span class="n">station_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;could not find station </span><span class="si">{</span><span class="n">station</span><span class="si">}</span><span class="s2"> in radar </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">station_id</span></div>


<div class="viewcode-block" id="Radar.set_beam"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.set_beam.html#sorts.radar.system.radar.Radar.set_beam">[docs]</a>    <span class="k">def</span> <span class="nf">set_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sets the radiation pattern for transmitters and receivers.</span>
<span class="sd">        </span>
<span class="sd">        This method sets the radiation pattern of the antennas associated to all :class:`TX&lt;sorts.radar.system.station.TX&gt;` and </span>
<span class="sd">        :class:`RX&lt;sorts.radar.system.station.RX&gt;` within the radar network.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beam : pyant.Beam</span>
<span class="sd">            Radiation pattern to set for all the stations within the radar system.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">            pyant.beam : defines the radiation pattern of radar antennas.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_tx_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_rx_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span></div>


<div class="viewcode-block" id="Radar.set_tx_beam"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.set_tx_beam.html#sorts.radar.system.radar.Radar.set_tx_beam">[docs]</a>    <span class="k">def</span> <span class="nf">set_tx_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sets the radiation pattern for transmitters.</span>
<span class="sd">        </span>
<span class="sd">        This method sets the radiation pattern of the antennas associated to all :class:`TX&lt;sorts.radar.system.station.TX&gt;` </span>
<span class="sd">        within the radar network.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beam : pyant.Beam</span>
<span class="sd">            Radiation pattern to set for all the `Transmitting` stations within the radar system.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">            pyant.beam : defines the radiation pattern of radar antennas.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">tx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">:</span>
            <span class="n">tx</span><span class="o">.</span><span class="n">beam</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="Radar.set_rx_beam"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.set_rx_beam.html#sorts.radar.system.radar.Radar.set_rx_beam">[docs]</a>    <span class="k">def</span> <span class="nf">set_rx_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sets the radiation pattern for receivers.</span>
<span class="sd">        </span>
<span class="sd">        This method sets the radiation pattern of the antennas associated to all :class:`TX&lt;sorts.radar.system.station.TX&gt;` </span>
<span class="sd">        within the radar network.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beam : pyant.Beam</span>
<span class="sd">            Radiation pattern to set for all the `Receiving` stations within the radar system.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">            pyant.beam : defines the radiation pattern of radar antennas.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">rx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span><span class="p">:</span>
            <span class="n">rx</span><span class="o">.</span><span class="n">beam</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="Radar.field_of_view"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.field_of_view.html#sorts.radar.system.radar.Radar.field_of_view">[docs]</a>    <span class="k">def</span> <span class="nf">field_of_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ecef</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns wether the given states are within the radar FOV.</span>

<span class="sd">        This method determines if the ecef states are within the FOV of all stations </span>
<span class="sd">        of the radar system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ecef : numpy.ndarray (6, N)</span>
<span class="sd">            States :math:`\vec{x} = [x, y, z, v_x, v_y, v_z]^T` in the ecef frame.            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray of bool (N,)</span>
<span class="sd">            For each ecef state, the value will be True if the state is inside the FOV of all stations, False if not. </span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To simplify this example, we will assume that we have created an array of space object states ``states`` in the ecef</span>
<span class="sd">        frame of 4 elements. Since all the stations within the radar have a FOV of 120 degrees (min elevation of 30 degrees),</span>
<span class="sd">        then we can create the directions :</span>

<span class="sd">        &gt;&gt;&gt; dir_1 = np.array([0.33087577, 0.12248111, 0.93569204, 0, 0, 0]) # 90 deg of elevation        </span>
<span class="sd">        &gt;&gt;&gt; dir_2 = np.array([0.18286604, 0.28205454, 0.94180956, 0, 0, 0]) # 77.5 deg of elevation     </span>
<span class="sd">        &gt;&gt;&gt; dir_3 = np.array([-0.1004115, 0.53090257, 0.84146301, 0, 0, 0]) # 55 deg of elevation       </span>
<span class="sd">        &gt;&gt;&gt; dir_4 = np.array([-0.6476016, 0.75067923, 0.13073926, 0, 0, 0]) # 0 deg of elevation</span>
<span class="sd">        &gt;&gt;&gt; dirs = np.asfarray([dir_1, dir_2, dir_3, dir_4]).T</span>
<span class="sd">        &gt;&gt;&gt; dirs</span>
<span class="sd">        array([[ 0.33087577,  0.18286604, -0.1004115 , -0.6476016 ],</span>
<span class="sd">               [ 0.12248111,  0.28205454,  0.53090257,  0.75067923],</span>
<span class="sd">               [ 0.93569204,  0.94180956,  0.84146301,  0.13073926],</span>
<span class="sd">               [ 0.        ,  0.        ,  0.        ,  0.        ],</span>
<span class="sd">               [ 0.        ,  0.        ,  0.        ,  0.        ],</span>
<span class="sd">               [ 0.        ,  0.        ,  0.        ,  0.        ]])</span>

<span class="sd">        If we assume that the directions point from the transmitting station to the space object state, then we get :</span>

<span class="sd">        &gt;&gt;&gt; ecef = dirs * np.array([[1550.0, 896.2, 1434.0, 4575.1]])*1e3</span>
<span class="sd">        &gt;&gt;&gt; ecef[0:3] = ecef[0:3] + self.radar.tx[0].ecef[:, None]</span>
<span class="sd">        &gt;&gt;&gt; ecef </span>
<span class="sd">        array([[2629440.29182936, 2280467.39337736, 1972592.75732936,</span>
<span class="sd">                -846259.23183064],</span>
<span class="sd">               [ 973346.45896828, 1036278.01721628, 1544815.02384828,</span>
<span class="sd">                4217933.28364128],</span>
<span class="sd">               [7395791.81355332, 6789518.87922532, 7152127.10789332,</span>
<span class="sd">                6543614.33997932],</span>
<span class="sd">               [      0.        ,       0.        ,       0.        ,</span>
<span class="sd">                      0.        ],</span>
<span class="sd">               [      0.        ,       0.        ,       0.        ,</span>
<span class="sd">                      0.        ],</span>
<span class="sd">               [      0.        ,       0.        ,       0.        ,</span>


<span class="sd">        We know that only the first three states will be within the FOV, so we will get : </span>

<span class="sd">        &gt;&gt;&gt; radar.field_of_view(ecef)</span>
<span class="sd">        array([ True,  True, True, False])</span>

<span class="sd">                </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">            sorts.radar.system.station.field_of_view : This method determines if the ecef states are within the FOV of a station </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ecef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">ecef</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">in_fov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ecef</span><span class="p">[</span><span class="mi">0</span><span class="p">]),),</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span><span class="p">:</span>
            <span class="n">in_fov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">in_fov</span><span class="p">,</span> <span class="n">station</span><span class="o">.</span><span class="n">field_of_view</span><span class="p">(</span><span class="n">ecef</span><span class="p">))</span>
           
        <span class="k">return</span> <span class="n">in_fov</span></div>


<div class="viewcode-block" id="Radar.find_passes"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.find_passes.html#sorts.radar.system.radar.Radar.find_passes">[docs]</a>    <span class="k">def</span> <span class="nf">find_passes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">cache_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Finds all passes that are simultaneously inside a transmitter </span>
<span class="sd">        station FOV and a receiver station FOV. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : numpy.ndarray (N,)</span>
<span class="sd">            Vector of times in seconds to use as a base to find passes.</span>
<span class="sd">        states : numpy.ndarray (6, N)</span>
<span class="sd">            ECEF states of the object to find passes for.</span>
<span class="sd">        cache_data : bool</span>
<span class="sd">            Wether the states will be stored.</span>
<span class="sd">            If True, the states will be stored in the ENU reference frame of each station.</span>
<span class="sd">            default value is True.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of list of sorts.radar.passes.Pass :</span>
<span class="sd">            list of passes indexed by first tx-station and then rx-station.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To simplify this example, we will assume that we have created an array of space object states ``states`` in the ecef</span>
<span class="sd">        frame of 4 elements. Since all the stations within the radar have a FOV of 120 degrees (min elevation of 30 degrees),</span>
<span class="sd">        then we can create the directions :</span>

<span class="sd">        &gt;&gt;&gt; dir_1 = np.array([0.33087577, 0.12248111, 0.93569204, 0, 0, 0]) # 90 deg of elevation        </span>
<span class="sd">        &gt;&gt;&gt; dir_2 = np.array([0.18286604, 0.28205454, 0.94180956, 0, 0, 0]) # 77.5 deg of elevation     </span>
<span class="sd">        &gt;&gt;&gt; dir_3 = np.array([-0.1004115, 0.53090257, 0.84146301, 0, 0, 0]) # 55 deg of elevation       </span>
<span class="sd">        &gt;&gt;&gt; dir_4 = np.array([-0.6476016, 0.75067923, 0.13073926, 0, 0, 0]) # 0 deg of elevation</span>
<span class="sd">        &gt;&gt;&gt; dirs = np.asfarray([dir_1, dir_2, dir_3, dir_4]).T</span>
<span class="sd">        &gt;&gt;&gt; dirs</span>
<span class="sd">        array([[ 0.33087577,  0.18286604, -0.1004115 , -0.6476016 ],</span>
<span class="sd">               [ 0.12248111,  0.28205454,  0.53090257,  0.75067923],</span>
<span class="sd">               [ 0.93569204,  0.94180956,  0.84146301,  0.13073926],</span>
<span class="sd">               [ 0.        ,  0.        ,  0.        ,  0.        ],</span>
<span class="sd">               [ 0.        ,  0.        ,  0.        ,  0.        ],</span>
<span class="sd">               [ 0.        ,  0.        ,  0.        ,  0.        ]])</span>

<span class="sd">        If we assume that the directions point from the transmitting station to the space object state, then we get :</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; t = numpy.array([0., 100., 200., 300.])</span>
<span class="sd">        &gt;&gt;&gt; ecef = dirs * np.array([[1550.0, 896.2, 1434.0, 4575.1]])*1e3</span>
<span class="sd">        &gt;&gt;&gt; ecef[0:3] = ecef[0:3] + self.radar.tx[0].ecef[:, None]</span>
<span class="sd">        &gt;&gt;&gt; ecef </span>
<span class="sd">        array([[2629440.29182936, 2280467.39337736, 1972592.75732936,</span>
<span class="sd">                -846259.23183064],</span>
<span class="sd">               [ 973346.45896828, 1036278.01721628, 1544815.02384828,</span>
<span class="sd">                4217933.28364128],</span>
<span class="sd">               [7395791.81355332, 6789518.87922532, 7152127.10789332,</span>
<span class="sd">                6543614.33997932],</span>
<span class="sd">               [      0.        ,       0.        ,       0.        ,</span>
<span class="sd">                      0.        ],</span>
<span class="sd">               [      0.        ,       0.        ,       0.        ,</span>
<span class="sd">                      0.        ],</span>
<span class="sd">               [      0.        ,       0.        ,       0.        ,</span>


<span class="sd">        We know that only the first three states will be within the FOV, so we will get : </span>

<span class="sd">        &gt;&gt;&gt; radar.find_passes(t, ecef)</span>
<span class="sd">        [[[Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f4721b066c0&gt;, &lt;sorts.radar.system.station.RX object at 0x7f470c1cb640&gt;] </span>
<span class="sd">        | Rise 0:00:00 (3.3 min) 0:03:20 Fall], </span>
<span class="sd">        [Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f4721b066c0&gt;, &lt;sorts.radar.system.station.RX object at 0x7f470c1cb540&gt;] </span>
<span class="sd">        | Rise 0:00:00 (3.3 min) 0:03:20 Fall], </span>
<span class="sd">        [Pass Station [&lt;sorts.radar.system.station.TX object at 0x7f4721b066c0&gt;, &lt;sorts.radar.system.station.RX object at 0x7f470c1cb840&gt;] </span>
<span class="sd">        | Rise 0:00:00 (3.3 min) 0:03:20 Fall]]]</span>

<span class="sd">        After a quick computation, one notices that 200 seconds is equal to 3 minutes and 20 seconds, which means that the object entered the FOV</span>
<span class="sd">        at :math:`t=0s` and left at :math:`t=200s`, which is coherent with our previous observation that only the first 3 states are within the FOV</span>
<span class="sd">        of the radar.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">rd_ps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">txi</span><span class="p">,</span> <span class="n">tx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">):</span>
            <span class="n">rd_ps</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">rxi</span><span class="p">,</span> <span class="n">rx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx</span><span class="p">):</span>
                <span class="n">txrx</span> <span class="o">=</span> <span class="n">passes</span><span class="o">.</span><span class="n">find_simultaneous_passes</span><span class="p">(</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> 
                    <span class="p">[</span><span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">],</span> 
                    <span class="n">cache_data</span><span class="o">=</span><span class="n">cache_data</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span> <span class="n">txrx</span><span class="p">:</span>
                    <span class="n">ps</span><span class="o">.</span><span class="n">station_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">txi</span><span class="p">,</span> <span class="n">rxi</span><span class="p">]</span>
                <span class="n">rd_ps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">txrx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rd_ps</span></div>


<div class="viewcode-block" id="Radar.check_control_feasibility"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.check_control_feasibility.html#sorts.radar.system.radar.Radar.check_control_feasibility">[docs]</a>    <span class="k">def</span> <span class="nf">check_control_feasibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">control_sequence</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function verifies if any of the controls are in conflict with the physical limitations of the RADAR (for example </span>
<span class="sd">        its speed, elevation, power, ...).</span>

<span class="sd">        This function can be freely overrided to check the feasibility of the controls wby a custom Radar system.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        control_sequence : sorts.radar.radar_controls.RadarControls</span>
<span class="sd">            RadarControls instance containing the controls to be sent to the radar. Such controls give the commanded states of the radar</span>
<span class="sd">            (such as power, pointing direction, ...) for each control time slice.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool :</span>
<span class="sd">            True if the controls are compatible with the radar system, False otherwise.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Radar.control"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.control.html#sorts.radar.system.radar.Radar.control">[docs]</a>    <span class="k">def</span> <span class="nf">control</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">control_sequence</span><span class="p">,</span> 
        <span class="n">cache_pdirs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
        <span class="n">cache_states</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Returns a control structure containing all the radar states for the given controls.</span>

<span class="sd">        This function computes the radar states resulting from the given control sequence. First, the algorithm</span>
<span class="sd">        will check if the specified control sequence is compatible with the radar physical constraints, and if yes,</span>
<span class="sd">        it will return the states of each station for each time slice.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default implementation of the Radar class does not include physical constraints. Therefore, if one needs to </span>
<span class="sd">            include such constraints, one needs to overload the :ref:`check_control_feasibility` function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        control_sequence : sorts.radar.radar_controls.RadarControls</span>
<span class="sd">            Control sequence instance used to control the radar. This control sequence must be compatible with the radar constraints.</span>
<span class="sd">        cache_pdirs : bool, default=True</span>
<span class="sd">            If true, the radar states structure will contain the numerical values of the pointing directions</span>

<span class="sd">            .. note::</span>
<span class="sd">                Enabling the ``cache_pdir`` option will increase the RAM usage, but also reduce computational time.</span>

<span class="sd">        cache_states : bool, default=True</span>
<span class="sd">            If true, the radar states structure will contain the numerical values of the space object&#39;s states.</span>

<span class="sd">            .. note::</span>
<span class="sd">                Enabling the ``cache_states`` option will increase the RAM usage, but also reduce computational time.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">            TODO</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_control_feasibility</span><span class="p">(</span><span class="n">control_sequence</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;radar:system:control: control sequence is not compatible with the radar system !&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># list of radar properties to be controlled</span>
        <span class="n">radar_states</span> <span class="o">=</span> <span class="n">control_sequence</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">cache_pdirs</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">radar_states</span><span class="o">.</span><span class="n">pdirs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">radar_states</span><span class="o">.</span><span class="n">has_pdirs</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">radar_states</span><span class="o">.</span><span class="n">set_pdirs</span><span class="p">(</span><span class="n">radar_states</span><span class="o">.</span><span class="n">pdir_args</span><span class="p">,</span> <span class="n">cache_pdirs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># first, the algorithm fills in all the values of the radar states which aren&#39;t being contolled </span>
        <span class="c1"># in the specific time slice</span>
        <span class="n">controlled</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">period_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">radar_states</span><span class="o">.</span><span class="n">n_periods</span><span class="p">):</span> 
            <span class="k">if</span> <span class="n">radar_states</span><span class="o">.</span><span class="n">property_controls</span><span class="p">[</span><span class="n">period_id</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">:</span>
                <span class="n">station_id</span> <span class="o">=</span> <span class="n">radar_states</span><span class="o">.</span><span class="n">radar</span><span class="o">.</span><span class="n">get_station_id</span><span class="p">(</span><span class="n">station</span><span class="p">)</span>
                <span class="n">station_type</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">type</span>

                <span class="c1"># for each controlled property of the station</span>
                <span class="k">for</span> <span class="n">property_name</span> <span class="ow">in</span> <span class="n">radar_states</span><span class="o">.</span><span class="n">controlled_properties</span><span class="p">[</span><span class="n">station_type</span><span class="p">][</span><span class="n">station_id</span><span class="p">]:</span>
                    <span class="c1"># check if the property is controlled during the specific period id</span>
                    <span class="k">if</span> <span class="n">property_name</span> <span class="ow">in</span> <span class="n">radar_states</span><span class="o">.</span><span class="n">property_controls</span><span class="p">[</span><span class="n">period_id</span><span class="p">][</span><span class="n">station_type</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">radar_states</span><span class="o">.</span><span class="n">property_controls</span><span class="p">[</span><span class="n">period_id</span><span class="p">][</span><span class="n">station_type</span><span class="p">][</span><span class="n">property_name</span><span class="p">][</span><span class="n">station_id</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">controlled</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1"># if not, create new set of controls</span>
                        <span class="n">n_stations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">radar_states</span><span class="o">.</span><span class="n">radar</span><span class="p">,</span> <span class="n">station_type</span><span class="p">))</span>
                        <span class="n">radar_states</span><span class="o">.</span><span class="n">property_controls</span><span class="p">[</span><span class="n">period_id</span><span class="p">][</span><span class="n">station_type</span><span class="p">][</span><span class="n">property_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n_stations</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

                    <span class="c1"># if there is no controls for the current property at the specified control period, set default value</span>
                    <span class="k">if</span> <span class="n">controlled</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">station</span><span class="p">,</span> <span class="n">property_name</span><span class="p">)</span>
                        <span class="n">radar_states</span><span class="o">.</span><span class="n">property_controls</span><span class="p">[</span><span class="n">period_id</span><span class="p">][</span><span class="n">station_type</span><span class="p">][</span><span class="n">property_name</span><span class="p">][</span><span class="n">station_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">radar_states</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">period_id</span><span class="p">]))</span>        

        <span class="c1"># create control fields for each stations properties which aren&#39;t controlled</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">:</span>
            <span class="n">station_id</span> <span class="o">=</span> <span class="n">radar_states</span><span class="o">.</span><span class="n">radar</span><span class="o">.</span><span class="n">get_station_id</span><span class="p">(</span><span class="n">station</span><span class="p">)</span>
            <span class="n">station_type</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">type</span>

            <span class="k">for</span> <span class="n">property_name</span> <span class="ow">in</span> <span class="n">station</span><span class="o">.</span><span class="n">get_properties</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">property_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">radar_states</span><span class="o">.</span><span class="n">controlled_properties</span><span class="p">[</span><span class="n">station_type</span><span class="p">][</span><span class="n">station_id</span><span class="p">]:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">station</span><span class="p">,</span> <span class="n">property_name</span><span class="p">)</span>
                    <span class="n">radar_states</span><span class="o">.</span><span class="n">add_property_control</span><span class="p">(</span><span class="n">property_name</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">data</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">radar_states</span><span class="o">.</span><span class="n">n_control_points</span><span class="p">))</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;added control </span><span class="si">{</span><span class="n">property_name</span><span class="si">}</span><span class="s2"> for station </span><span class="si">{</span><span class="n">station_type</span><span class="si">}</span><span class="s2"> id </span><span class="si">{</span><span class="n">station_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># remove from controlled properties (to hide from controlled properties)</span>
                    <span class="n">radar_states</span><span class="o">.</span><span class="n">controlled_properties</span><span class="p">[</span><span class="n">station_type</span><span class="p">][</span><span class="n">station_id</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">radar_states</span>
   
        <span class="k">return</span> <span class="n">radar_states</span></div>

<div class="viewcode-block" id="Radar.compute_measurements"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.compute_measurements.html#sorts.radar.system.radar.Radar.compute_measurements">[docs]</a>    <span class="k">def</span> <span class="nf">compute_measurements</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">radar_states</span><span class="p">,</span> 
        <span class="n">space_object</span><span class="p">,</span>
        <span class="n">rx_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tx_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epoch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
        <span class="n">calculate_snr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
        <span class="n">doppler_spread_integrated_snr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">interpolator</span><span class="o">=</span><span class="n">interpolation</span><span class="o">.</span><span class="n">Linear</span><span class="p">,</span> 
        <span class="n">max_dpos</span><span class="o">=</span><span class="mf">50e3</span><span class="p">,</span>
        <span class="n">snr_limit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
        <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save_states</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
        <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">profiler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">interrupt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">parallelization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">n_processes</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Simulates radar measurements associated to an object and to a set of radar states.</span>

<span class="sd">        This function wraps the function :func:`measure&lt;sorts.radar.measurement.base.Measurement.measure&gt;` and provides an easy to </span>
<span class="sd">        use interface to simulateradar observations of space objects (SNR, range, Range rates, ...).</span>

<span class="sd">        .. seealso::</span>
<span class="sd">            See :attr:`sorts.Measurement.compute_space_object_measurements&lt;sorts.radar.system.measurements.</span>
<span class="sd">            Measurement.compute_space_object_measurements&gt;` to obtain more information about the way measurements</span>
<span class="sd">            are simulated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        radar_states : sorts.radar.radar_controls.RadarControls</span>
<span class="sd">            Radar states during the measurement. </span>
<span class="sd">            Radar states can be generated by calling the function :func:`control&lt;Radar.control&gt;` providing that the control </span>
<span class="sd">            sequence is feasable by the radar system.        </span>
<span class="sd">        space_object : sorts.target.space_object.SpaceObject</span>
<span class="sd">            :class:`SpaceObject&lt;sorts.targets.space_object.SpaceObject&gt;` instance which is subject to the measurement.</span>
<span class="sd">        rx_indices : list of int/None, default=None</span>
<span class="sd">            List of indices of :class:`RX&lt;sorts.radar.system.station.RX&gt;` stations performing the measurement simultaneously.</span>
<span class="sd">        tx_indices : list of int/None, default=None</span>
<span class="sd">            List of indices of :class:`TX&lt;sorts.radar.system.station.TX&gt;` stations performing the measurement simultaneously.</span>
<span class="sd">        epoch : float/None, default=None, </span>
<span class="sd">            Time epoch at the start of the simulation in Modified Julian Date format. See :class:`astropy.time.TimeMJD` for more </span>
<span class="sd">            information.</span>
<span class="sd">        calculate_snr=True, </span>
<span class="sd">            If true, the simulation will compute the Signal-To-Noise ratio predictions given the radar and object states.</span>
<span class="sd">        doppler_spread_integrated_snr=False,</span>
<span class="sd">            If true, the simulation will compute the Doppler Spread Integrated Signal-To-Noise ratio predictions given the radar </span>
<span class="sd">            and object states.</span>
<span class="sd">        interpolator : sorts.common.interpolation.Interpolator, default=interpolation.Linear, </span>
<span class="sd">            Interpolation class used to interpolate radar states from low time-resolution computations.</span>
<span class="sd">        max_dpos=50e3,</span>
<span class="sd">            Maximum distance between two consecutive low time-resolition propagated states.</span>
<span class="sd">            see :func:`measure&lt;sorts.radar.measurement.base.Measurement.measure&gt;` for more information.</span>
<span class="sd">        snr_limit : bool, default=``True``, </span>
<span class="sd">            If True, SNR measurements under the minimum value provided by :ref:`min_SNRdb&lt;minsnrdb&gt;`_ will be discarded.</span>
<span class="sd">        exact : bool, default=False</span>
<span class="sd">            If True, the states will be propagated at each time point ``t``, if not, they will be propagated to </span>
<span class="sd">            meet the condition set by ``max_dpos``.</span>
<span class="sd">        save_states : bool, default=``False``, </span>
<span class="sd">            If True, propagated and interpolated space object states will be saved and returned within the :ref:`output data </span>
<span class="sd">            structure&lt;compute_measurements_ret&gt;`_.</span>
<span class="sd">        logger : sorts.common.logging.Logger instance, default=``None``,</span>
<span class="sd">            Logger used to keep track of the measurement simulation process.</span>
<span class="sd">        profiler : sorts.common.profiling.Profiler instance, default=None</span>
<span class="sd">            Profiler used to keep track of the performances of the measurement simulation process.</span>
<span class="sd">        interrupt : bool, default=False</span>
<span class="sd">            If ``True``, the measurement simulator will evalate the stop condition (defined within </span>
<span class="sd">            the :attr:`sorts.Measurement.stop_condition&lt;sorts.radar.measurements.measurement.Measurement.stop_condition&gt;`)</span>
<span class="sd">            The simulation will stop at the first time step where the condition is satisfied and return the results of the</span>
<span class="sd">            previous steps.</span>

<span class="sd">            .. note::</span>
<span class="sd">                The default implementation of sorts does not provide any implementation for the ``stop_condition`` method.</span>
<span class="sd">                Therefore, to use the stop_condition feature, it is necessary to create a new :class:`sorts.Measurement</span>
<span class="sd">                &lt;sorts.radar.measurements.measurement.Measurement&gt;` class inherited from the first measurement</span>
<span class="sd">                class and provide a custom implementation satisfying the requirements of the project.</span>
<span class="sd">                </span>
<span class="sd">        parallelization : bool, default=``True``</span>
<span class="sd">            If True, the simulation will be parallelized using process-based parallelisation.</span>
<span class="sd">            The current implementation is based on the python :ref:`multiprocessing` library.</span>
<span class="sd">        n_processes : int, default=16</span>
<span class="sd">            Maximum number of simultaneous processes used when :attr:`parallelization` is ``True``.</span>

<span class="sd">        .. _compute_measurements_ret::</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : list of dict</span>
<span class="sd">            List of measurement data structure, see :attr:`Measurement.measure_states` for more information about the </span>
<span class="sd">            output data structure of the measurement simulation.</span>
<span class="sd">            The list of data structures is arranged such that ``data[txi][rxi][pi]`` corresponds to the measurement data</span>
<span class="sd">            of the ``pi``^th pass over the Tx station of index ``txi`` and the Rx station of index ``rxi``.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_class</span><span class="o">.</span><span class="n">compute_space_object_measurements</span><span class="p">(</span>
            <span class="n">radar_states</span><span class="p">,</span> 
            <span class="n">space_object</span><span class="p">,</span> 
            <span class="n">tx_indices</span><span class="o">=</span><span class="n">tx_indices</span><span class="p">,</span>
            <span class="n">rx_indices</span><span class="o">=</span><span class="n">rx_indices</span><span class="p">,</span>
            <span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span><span class="p">,</span> 
            <span class="n">calculate_snr</span><span class="o">=</span><span class="n">calculate_snr</span><span class="p">,</span> 
            <span class="n">doppler_spread_integrated_snr</span><span class="o">=</span><span class="n">doppler_spread_integrated_snr</span><span class="p">,</span>
            <span class="n">interpolator</span><span class="o">=</span><span class="n">interpolation</span><span class="o">.</span><span class="n">Legendre8</span><span class="p">,</span> 
            <span class="n">max_dpos</span><span class="o">=</span><span class="n">max_dpos</span><span class="p">,</span>
            <span class="n">exact</span><span class="o">=</span><span class="n">exact</span><span class="p">,</span>
            <span class="n">snr_limit</span><span class="o">=</span><span class="n">snr_limit</span><span class="p">,</span> 
            <span class="n">save_states</span><span class="o">=</span><span class="n">save_states</span><span class="p">,</span> 
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="n">profiler</span><span class="o">=</span><span class="n">profiler</span><span class="p">,</span>
            <span class="n">parallelization</span><span class="o">=</span><span class="n">parallelization</span><span class="p">,</span>
            <span class="n">n_processes</span><span class="o">=</span><span class="n">n_processes</span><span class="p">,</span>
            <span class="n">interrupt</span><span class="o">=</span><span class="n">interrupt</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Radar.observe_passes"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.observe_passes.html#sorts.radar.system.radar.Radar.observe_passes">[docs]</a>    <span class="k">def</span> <span class="nf">observe_passes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">pass_list</span><span class="p">,</span>
        <span class="n">radar_states</span><span class="p">,</span> 
        <span class="n">space_object</span><span class="p">,</span> 
        <span class="n">epoch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
        <span class="n">calculate_snr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
        <span class="n">doppler_spread_integrated_snr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">interpolator</span><span class="o">=</span><span class="n">interpolation</span><span class="o">.</span><span class="n">Legendre8</span><span class="p">,</span> 
        <span class="n">max_dpos</span><span class="o">=</span><span class="mf">100e3</span><span class="p">,</span>
        <span class="n">snr_limit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
        <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_cached_states</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">save_states</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
        <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">profiler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">interrupt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">parallelization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">n_processes</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Simulates radar measurements associated to an object and to a set of radar states.</span>

<span class="sd">        This function wraps the function :func:`measure&lt;sorts.radar.measurement.base.Measurement.measure&gt;` and provides an easy to use interface to simulate</span>
<span class="sd">        radar observations of space objects (SNR, range, Range rates, ...).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pass_list : sorts.Pass </span>
<span class="sd">            List of object passes over the radar system which we want to observe.</span>
<span class="sd">        radar_states : sorts.radar.radar_controls.RadarControls</span>
<span class="sd">            Radar states during the measurement. </span>
<span class="sd">            Radar states can be generated by calling the function :func:`control&lt;Radar.control&gt;` providing that the control sequence is feasable by the radar </span>
<span class="sd">            system.        </span>
<span class="sd">        space_object : sorts.target.space_object.SpaceObject</span>
<span class="sd">            :class:`SpaceObject&lt;sorts.targets.space_object.SpaceObject&gt;` instance which is subject to the measurement.</span>
<span class="sd">        rx_indices : list of int/None, default=None</span>
<span class="sd">            List of indices of :class:`RX&lt;sorts.radar.system.station.RX&gt;` stations performing the measurement simultaneously.</span>
<span class="sd">        tx_indices : list of int/None, default=None</span>
<span class="sd">            List of indices of :class:`TX&lt;sorts.radar.system.station.TX&gt;` stations performing the measurement simultaneously.</span>
<span class="sd">        epoch : float/None, default=None, </span>
<span class="sd">            Time epoch at the start of the simulation in Modified Julian Date format. See :class:`astropy.time.TimeMJD` for more information.</span>
<span class="sd">        calculate_snr=True, </span>
<span class="sd">            If true, the simulation will compute the Signal-To-Noise ratio predictions given the radar and object states.</span>
<span class="sd">        doppler_spread_integrated_snr=False,</span>
<span class="sd">            If true, the simulation will compute the Doppler Spread Integrated Signal-To-Noise ratio predictions given the radar and object states.</span>
<span class="sd">        interpolator : sorts.common.interpolation.Interpolator, default=interpolation.Linear, </span>
<span class="sd">            Interpolation class used to interpolate radar states from low time-resolution computations.</span>
<span class="sd">        max_dpos=50e3,</span>
<span class="sd">            Maximum distance between two consecutive low time-resolition propagated states.</span>
<span class="sd">            see :func:`measure&lt;sorts.radar.measurement.base.Measurement.measure&gt;` for more information.</span>
<span class="sd">        exact : bool, default=False</span>
<span class="sd">            If True, the states will be propagated at each time point ``t``, if not, they will be propagated to </span>
<span class="sd">            meet the condition set by ``max_dpos``.</span>
<span class="sd">        use_cached_states : bool, default=True</span>
<span class="sd">            If True, the function will use the space object states cached within the radar pass if available.</span>
<span class="sd">        snr_limit : bool, default=``True``, </span>
<span class="sd">            If True, SNR measurements under the minimum value provided by :ref:`min_SNRdb&lt;minsnrdb&gt;`_ will be discarded.</span>
<span class="sd">        save_states : bool, default=``False``, </span>
<span class="sd">            If True, propagated and interpolated space object states will be saved and returned within the :ref:`output data structure&lt;compute_measurements_ret&gt;`_.</span>
<span class="sd">        logger : sorts.common.logging.Logger instance, default=``None``,</span>
<span class="sd">            Logger used to keep track of the measurement simulation process.</span>
<span class="sd">        profiler : sorts.common.profiling.Profiler instance, default=None</span>
<span class="sd">            Profiler used to keep track of the performances of the measurement simulation process.</span>
<span class="sd">        interrupt : bool, default=False</span>
<span class="sd">            If ``True``, the measurement simulator will evalate the stop condition (defined within </span>
<span class="sd">            the :attr:`sorts.Measurement.stop_condition&lt;sorts.radar.measurements.measurement.Measurement.stop_condition&gt;`)</span>
<span class="sd">            The simulation will stop at the first time step where the condition is satisfied and return the results of the</span>
<span class="sd">            previous steps.</span>

<span class="sd">            .. note::</span>
<span class="sd">                The default implementation of sorts does not provide any implementation for the ``stop_condition`` method.</span>
<span class="sd">                Therefore, to use the stop_condition feature, it is necessary to create a new :class:`sorts.Measurement</span>
<span class="sd">                &lt;sorts.radar.measurements.measurement.Measurement&gt;` class inherited from the first measurement</span>
<span class="sd">                class and provide a custom implementation satisfying the requirements of the project.</span>
<span class="sd">                </span>
<span class="sd">        parallelization : bool, default=``True``</span>
<span class="sd">            If True, the simulation will be parallelized using process-based parallelisation.</span>
<span class="sd">            The current implementation is based on the python :ref:`multiprocessing` library.</span>
<span class="sd">        n_processes : int, default=16</span>
<span class="sd">            Maximum number of simultaneous processes used when :attr:`parallelization` is ``True``.</span>


<span class="sd">        .. _compute_measurements_ret::</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : list of dict</span>
<span class="sd">            List of measurement data structure, see :attr:`Measurement.measure_states` for more information about the </span>
<span class="sd">            output data structure of the measurement simulation.</span>
<span class="sd">            The list of data structures is arranged such that ``data[txi][rxi][pi]`` corresponds to the measurement data</span>
<span class="sd">            of the ``pi``^th pass over the Tx station of index ``txi`` and the Rx station of index ``rxi``.</span>

<span class="sd">        Examples </span>
<span class="sd">        --------</span>
<span class="sd">        Before simulating a measurement, we need to define the radar system as well as the radar controls which will be </span>
<span class="sd">        executed during the measurement. </span>

<span class="sd">        &gt;&gt;&gt; import sorts</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; radar = sorts.radars.eiscat3d</span>

<span class="sd">        Consider now a space object (Kepler propagator) passing over the **EISCAT_3D** radar system:</span>

<span class="sd">        &gt;&gt;&gt; Prop_cls = sorts.propagator.Kepler</span>
<span class="sd">        &gt;&gt;&gt; Prop_opts = dict(</span>
<span class="sd">        ...         settings = dict(</span>
<span class="sd">        ...                 out_frame=&#39;ITRS&#39;,</span>
<span class="sd">        ...                 in_frame=&#39;TEME&#39;,</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; space_object = sorts.SpaceObject(</span>
<span class="sd">        ...         Prop_cls,</span>
<span class="sd">        ...         propagator_options = Prop_opts,</span>
<span class="sd">        ...         a = 7000e3, </span>
<span class="sd">        ...         e = 0.0,</span>
<span class="sd">        ...         i = 78,</span>
<span class="sd">        ...         raan = 86,</span>
<span class="sd">        ...         aop = 0, </span>
<span class="sd">        ...         mu0 = 50,</span>
<span class="sd">        ...         epoch = 53005.0,</span>
<span class="sd">        ...         parameters = dict(</span>
<span class="sd">        ...                 d = 0.1,</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ... )</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; print(space_object)</span>
<span class="sd">        Space object 1: &lt;Time object: scale=&#39;utc&#39; format=&#39;mjd&#39; value=53005.0&gt;:</span>
<span class="sd">        a    : 7.0000e+06   x : -7.9830e+05</span>
<span class="sd">        e    : 0.0000e+00   y : 4.5663e+06</span>
<span class="sd">        i    : 7.8000e+01   z : 5.2451e+06</span>
<span class="sd">        omega: 0.0000e+00   vx: -1.4093e+03</span>
<span class="sd">        Omega: 8.6000e+01   vy: -5.6962e+03</span>
<span class="sd">        anom : 5.0000e+01   vz: 4.7445e+03</span>
<span class="sd">        Parameters: C_D=2.3, m=1.0, C_R=1.0, d=0.1</span>
<span class="sd">    </span>
<span class="sd">        The states are propagated over a time period of 1 day:</span>

<span class="sd">        &gt;&gt;&gt; t_states = sorts.equidistant_sampling(</span>
<span class="sd">        ...         orbit=space_object.state, </span>
<span class="sd">        ...         start_t=0, </span>
<span class="sd">        ...         end_t=3600.0, </span>
<span class="sd">        ...         max_dpos=10e3)</span>
<span class="sd">        &gt;&gt;&gt; object_states = space_object.get_state(t_states)</span>
<span class="sd">        </span>
<span class="sd">        We can recover the passes over the radar station by running:</span>

<span class="sd">        &gt;&gt;&gt; passes = sorts.passes.find_simultaneous_passes(t_states, object_states, radar.tx+radar.rx, cache_data=True)</span>
<span class="sd">        [Pass Station [&lt;sorts.radar.system.station.TX object at 0x7ff9af6ccac0&gt;, </span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7ff99523ba40&gt;, </span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7ff9951db2c0&gt;, </span>
<span class="sd">        &lt;sorts.radar.system.station.RX object at 0x7ff9951db4c0&gt;] | </span>
<span class="sd">        Rise 0:04:05.161251 (4.1 min) 0:08:10.322502 Fall]</span>

<span class="sd">        For the sake of this example, suppose that the radar is controlled by a Tracking controller:</span>

<span class="sd">        &gt;&gt;&gt; controller = sorts.Tracker()</span>

<span class="sd">        We can generate the controls for the first pass by running:</span>

<span class="sd">        &gt;&gt;&gt; tracking_states = object_states[:, passes[0].inds]</span>
<span class="sd">        &gt;&gt;&gt; t_states_i = t_states[passes[0].inds]</span>
<span class="sd">        &gt;&gt;&gt; t_controller = np.arange(t_states_i[0], t_states_i[-1], 10)</span>
<span class="sd">        &gt;&gt;&gt; controls = controller.generate_controls(</span>
<span class="sd">        ...         t_controller, </span>
<span class="sd">        ...         radar, </span>
<span class="sd">        ...         t_states_i, </span>
<span class="sd">        ...         tracking_states, </span>
<span class="sd">        ...         t_slice=0.1, </span>
<span class="sd">        ...         scheduler=None, </span>
<span class="sd">        ...         states_per_slice=1, </span>
<span class="sd">        ...         interpolator=sorts.interpolation.Legendre8)</span>

<span class="sd">        From which we can generate the radar states during the Tracking time interval:</span>

<span class="sd">        &gt;&gt;&gt; radar_states = radar.control(controls)</span>

<span class="sd">        Finally, we can run the measurement simulation over the pass by finding the corresponding pass</span>
<span class="sd">        for each tuple of station (tx/rx) and running the ``observe_passes`` function:</span>

<span class="sd">        &gt;&gt;&gt; pass_list = radar.find_passes(t_states_i, tracking_states, cache_data=True)</span>
<span class="sd">        &gt;&gt;&gt; data = radar.observe_passes(pass_list, radar_states, space_object)</span>

<span class="sd">        We can then print the results by executing the following instructions:</span>

<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax1 = fig.add_subplot(311)</span>
<span class="sd">        &gt;&gt;&gt; ax2 = fig.add_subplot(312, sharex=ax1)</span>
<span class="sd">        &gt;&gt;&gt; ax3 = fig.add_subplot(313, sharex=ax1)</span>
<span class="sd">        &gt;&gt;&gt; fmt = [&quot;-r&quot;, &quot;-g&quot;, &quot;-b&quot;]</span>
<span class="sd">        &gt;&gt;&gt; for station_id in range(len(radar.rx)):</span>
<span class="sd">        ...         measurements = data[0][station_id][0][&quot;measurements&quot;] # extract measurements for each rx station for the first pass</span>
<span class="sd">        ...         ax1.plot(measurements[&#39;t_measurements&#39;], measurements[&#39;range&#39;]*1e-3, fmt[station_id], label=f&quot;rx{station_id}&quot;)</span>
<span class="sd">        ...         ax2.plot(measurements[&#39;t_measurements&#39;], measurements[&#39;range_rate&#39;]*1e-3, fmt[station_id], label=f&quot;rx{station_id}&quot;)</span>
<span class="sd">        ...         ax3.plot(measurements[&#39;t_measurements&#39;], 10*np.log10(measurements[&#39;snr&#39;]), fmt[station_id], label=f&quot;rx{station_id}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax1.set_ylabel(&quot;$R$ [$km$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax2.set_ylabel(&quot;$v_r$ [$km/s$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax3.set_ylabel(&quot;$\\rho$ [$dB$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax3.set_xlabel(&quot;$t$ [$s$]&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax1.tick_params(labeltop=False, labelbottom=False)</span>
<span class="sd">        &gt;&gt;&gt; ax2.tick_params(labeltop=False, labelbottom=False)</span>
<span class="sd">        &gt;&gt;&gt; ax3.tick_params(labeltop=False)</span>
<span class="sd">        &gt;&gt;&gt; ax1.grid()</span>
<span class="sd">        &gt;&gt;&gt; ax2.grid()</span>
<span class="sd">        &gt;&gt;&gt; ax3.grid()</span>
<span class="sd">        &gt;&gt;&gt; fig.subplots_adjust(hspace=0)</span>
<span class="sd">        &gt;&gt;&gt; plt.legend()</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">        Which gives us the following results:</span>

<span class="sd">        .. figure:: ../../../../figures/radar_example_observe_passes.png</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">radar_states</span><span class="o">.</span><span class="n">pdirs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;t&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_end</span>   <span class="o">=</span> <span class="n">radar_states</span><span class="o">.</span><span class="n">pdirs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;t&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pass_iter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># count all passes</span>
        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_passes</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">txi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pass_list</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">rxi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pass_list</span><span class="p">[</span><span class="n">txi</span><span class="p">])):</span>
                    <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span> <span class="n">pass_list</span><span class="p">[</span><span class="n">txi</span><span class="p">][</span><span class="n">rxi</span><span class="p">]:</span>
                        <span class="n">n_passes</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># observe pass</span>
        <span class="k">for</span> <span class="n">txi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pass_list</span><span class="p">)):</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">rxi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pass_list</span><span class="p">[</span><span class="n">txi</span><span class="p">])):</span>
                <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span> <span class="n">pass_list</span><span class="p">[</span><span class="n">txi</span><span class="p">][</span><span class="n">rxi</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">ps</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">t_end</span> <span class="ow">or</span> <span class="n">ps</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">t_start</span><span class="p">:</span> <span class="c1"># if the pass is outside of the control range</span>
                        <span class="n">pass_data</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ps</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">t_start</span> <span class="ow">or</span> <span class="n">ps</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">t_end</span><span class="p">:</span> <span class="c1"># if the pass is partially outside of the control range, remove parts which are outside</span>
                            <span class="k">if</span> <span class="n">ps</span><span class="o">.</span><span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">pass_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">ps</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">t_end</span><span class="p">)</span>
                                <span class="n">pass_inds</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">pass_mask</span><span class="p">]</span>

                                <span class="n">enu_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">xv</span><span class="p">[:,</span> <span class="n">pass_inds</span><span class="p">]</span> <span class="k">for</span> <span class="n">xv</span> <span class="ow">in</span> <span class="n">ps</span><span class="o">.</span><span class="n">enu</span><span class="p">]</span>

                                <span class="n">new_ps</span> <span class="o">=</span> <span class="n">passes</span><span class="o">.</span><span class="n">Pass</span><span class="p">(</span>
                                    <span class="n">t</span><span class="o">=</span><span class="n">ps</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">pass_mask</span><span class="p">],</span> 
                                    <span class="n">enu</span><span class="o">=</span><span class="n">enu_new</span><span class="p">,</span> 
                                    <span class="n">inds</span><span class="o">=</span><span class="n">pass_inds</span><span class="p">,</span> 
                                    <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">new_ps</span> <span class="o">=</span> <span class="n">passes</span><span class="o">.</span><span class="n">Pass</span><span class="p">(</span>
                                    <span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">]),</span> 
                                    <span class="n">enu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="n">inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="n">ps</span> <span class="o">=</span> <span class="n">new_ps</span>
                            <span class="n">ps</span><span class="o">.</span><span class="n">station_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">txi</span><span class="p">,</span> <span class="n">rxi</span><span class="p">]</span>

                        <span class="n">pass_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_class</span><span class="o">.</span><span class="n">compute_pass_measurements</span><span class="p">(</span>
                            <span class="n">ps</span><span class="p">,</span>
                            <span class="n">radar_states</span><span class="p">,</span> 
                            <span class="n">space_object</span><span class="p">,</span> 
                            <span class="n">epoch</span><span class="o">=</span><span class="n">epoch</span><span class="p">,</span> 
                            <span class="n">calculate_snr</span><span class="o">=</span><span class="n">calculate_snr</span><span class="p">,</span> 
                            <span class="n">doppler_spread_integrated_snr</span><span class="o">=</span><span class="n">doppler_spread_integrated_snr</span><span class="p">,</span>
                            <span class="n">interpolator</span><span class="o">=</span><span class="n">interpolator</span><span class="p">,</span> 
                            <span class="n">max_dpos</span><span class="o">=</span><span class="n">max_dpos</span><span class="p">,</span>
                            <span class="n">snr_limit</span><span class="o">=</span><span class="n">snr_limit</span><span class="p">,</span> 
                            <span class="n">exact</span><span class="o">=</span><span class="n">exact</span><span class="p">,</span>
                            <span class="n">use_cached_states</span><span class="o">=</span><span class="n">use_cached_states</span><span class="p">,</span>
                            <span class="n">save_states</span><span class="o">=</span><span class="n">save_states</span><span class="p">,</span> 
                            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
                            <span class="n">profiler</span><span class="o">=</span><span class="n">profiler</span><span class="p">,</span>
                            <span class="n">parallelization</span><span class="o">=</span><span class="n">parallelization</span><span class="p">,</span>
                            <span class="n">n_processes</span><span class="o">=</span><span class="n">n_processes</span><span class="p">,</span>
                            <span class="n">interrupt</span><span class="o">=</span><span class="n">interrupt</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="n">pass_iter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;observe_passes: iteration </span><span class="si">{</span><span class="n">pass_iter</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">n_passes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pass_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="Radar.compute_intersection_points"><a class="viewcode-back" href="../../../../reference/radar/system/radar/sorts.radar.system.radar.Radar.compute_intersection_points.html#sorts.radar.system.radar.Radar.compute_intersection_points">[docs]</a>    <span class="k">def</span> <span class="nf">compute_intersection_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tx_directions</span><span class="p">,</span>
        <span class="n">rx_directions</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Computes the ECEF points (if they exist) targetted by pointing direction controls.</span>

<span class="sd">        Given a set of pointing directions :math:`(\hat{k_{tx}}, \hat{k_{rx}})` and the positions of the stations (from which we can extract the vector </span>
<span class="sd">        :math:`\hat{k_{tx, rx}`), one can compute the theoretical point which was targetted (given that the 3 prevous vectors lie in the same plane) </span>
<span class="sd">        using the formula :</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">               \vec{r^{ij}} = \vec{r_{tx}^i} + \lambda_{ij} \hat{k_{tx}^i}</span>

<span class="sd">        with :</span>

<span class="sd">        .. math::</span>
<span class="sd">            \lambda_{ij} = \frac{(\vec{r_{tx}^i} - \vec{r_{rx}^j}) ((\hat{k_{tx}^i} \dot \hat{k_{rx}^j}) \hat{k_{rx}^j} - \hat{k_{tx}^i})}{1 - (\hat{k_{tx}^i} \dot \hat{k_{rx}^j})^2}</span>
<span class="sd">        </span>
<span class="sd">        The algorithm computes the intersection points :math:`\vec{r^{ij}}` for each (tx[i], rx[j]) tuple of stations inside the radar system. Then, we compute the</span>
<span class="sd">        barycenter for each tx[i] station :</span>

<span class="sd">        ..  math::</span>
<span class="sd">            \vec{r^{i}} = \frac{1}{N_{rx}} \sum_{k=0}^{N_{rx}-1}\vec{r^{ik}}</span>

<span class="sd">        And then we compute the relative distance of each point :math:`\vec{r^{ij}}` to the barycenter :math:`\vec{r^{i}}` :</span>
<span class="sd">        </span>
<span class="sd">        ..  math::</span>
<span class="sd">            \alpha_{ij} = \frac{\| \vec{r^{ij}} - \vec{r^{i}} \|}{\| \vec{r^{ij}} \|}</span>

<span class="sd">        If :math:`\alpha_{ij} &gt; \alpha_{tol}`, we discard the intersection point, and if not, we keep the barycenter :math:`\vec{r^{i}}` as the intersection point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tx_directions : numpy.array (Ntx, 1, 3, N)</span>
<span class="sd">            Transmitting stations pointing directions.</span>
<span class="sd">        rx_directions : numpy.array (Nrx, Ntx, 3, N)</span>
<span class="sd">            Receiving stations pointing directions.</span>
<span class="sd">        rtol : float, default=0.05</span>
<span class="sd">            Relative tolerance threshold over which we discard the intersection point at time t.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------- </span>
<span class="sd">        numpy.ndarray (3, N) :</span>
<span class="sd">            Array of ecef points targetted by the pointing direction controls.</span>

<span class="sd">        ..notes::</span>
<span class="sd">            Since this function was designed only for plotting, it only returns the intersection points which were found during the routine and not those which were discarded.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Pointing direction controls are usually generated from a set of ECEF points. For this example, we will consider a point situated directly over the Tx station of </span>
<span class="sd">        the EISCAT_3D radar.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; import sorts</span>
<span class="sd">        &gt;&gt;&gt; radar = sorts.radars.eiscat3d</span>

<span class="sd">        We can compute the theoretical ecef position of the point located at a range of 1000km:</span>

<span class="sd">        &gt;&gt;&gt; dir_enu = np.array([0., 0., 1.])</span>
<span class="sd">        &gt;&gt;&gt; r_ecef = sorts.frames.enu_to_ecef(radar.tx[0].lat, radar.tx[0].lon, 0., dir_enu)*1e6 + radar.tx[0].ecef</span>
<span class="sd">        &gt;&gt;&gt; r_ecef</span>
<span class="sd">        array([2447458.62326276,  905981.8472074 , 6881161.19467662])</span>

<span class="sd">        Then we can compute the pointing directions of each station :</span>

<span class="sd">        tx_ecef = np.array([tx.ecef for tx in radar.tx])[:, None, :, None]</span>
<span class="sd">        rx_ecef = np.array([rx.ecef for rx in radar.rx])[:, None, :, None]</span>

<span class="sd">        Tx pointing direction :</span>

<span class="sd">        &gt;&gt;&gt; tx_dirs = r_ecef[None, None, :, None] - tx_ecef</span>
<span class="sd">        &gt;&gt;&gt; tx_dirs = tx_dirs/np.linalg.norm(tx_dirs, axis=2)[:, :, None, :]</span>
<span class="sd">        array([[[[0.33087577],</span>
<span class="sd">                 [0.12248111],</span>
<span class="sd">                 [0.93569204]]]])</span>

<span class="sd">        Rx pointing directions :</span>

<span class="sd">        &gt;&gt;&gt; rx_dirs = r_ecef[None, None, :, None] - rx_ecef</span>
<span class="sd">        &gt;&gt;&gt; rx_dirs = rx_dirs/np.linalg.norm(rx_dirs, axis=2)[:, :, None, :]</span>
<span class="sd">        &gt;&gt;&gt; rx_dirs</span>
<span class="sd">        array([[[[0.33087577],</span>
<span class="sd">                 [0.12248111],</span>
<span class="sd">                 [0.93569204]]],</span>


<span class="sd">               [[[0.27472276],</span>
<span class="sd">                 [0.00885592],</span>
<span class="sd">                 [0.9614827 ]]],</span>


<span class="sd">               [[[0.20478789],</span>
<span class="sd">                 [0.09962972],</span>
<span class="sd">                 [0.97372267]]]])</span>
<span class="sd">        </span>
<span class="sd">        Notice that we have don&#39;t have direct access to the range information of the point we started with using only ``rx_dirs`` and ``tx_dirs``, which </span>
<span class="sd">        complicates the plotting of the pointing directions. Therefore, we can call ``compute_intersection_points`` to get the original point ``r_ecef`` :</span>

<span class="sd">        &gt;&gt;&gt; radar.compute_intersection_points(tx_dirs, rx_dirs)</span>
<span class="sd">        array([[2447458.62326275],</span>
<span class="sd">               [ 905981.8472074 ],</span>
<span class="sd">               [6881161.19467661]])</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tx_directions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">rx_directions</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tx and rx pdirs directions are not the same shape : </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tx_directions</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">rx_directions</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># radar pointing directions</span>
        <span class="n">tx_directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">(</span><span class="n">tx_directions</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">rx_directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">(</span><span class="n">rx_directions</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># radar station positions in ECEF coordinates</span>
        <span class="n">tx_ecef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tx</span><span class="o">.</span><span class="n">ecef</span> <span class="k">for</span> <span class="n">tx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">rx_ecef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rx</span><span class="o">.</span><span class="n">ecef</span> <span class="k">for</span> <span class="n">rx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># initialization of the computation results</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rx_directions</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="c1"># number of time points</span>

        <span class="n">intersection_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_points</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_points</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Calling c library</span>
        <span class="n">clibsorts</span><span class="o">.</span><span class="n">compute_intersection_points</span><span class="p">(</span>
            <span class="n">tx_directions</span><span class="p">,</span>
            <span class="n">rx_directions</span><span class="p">,</span>
            <span class="n">tx_ecef</span><span class="p">,</span>
            <span class="n">rx_ecef</span><span class="p">,</span>
            <span class="n">intersection_points</span><span class="p">,</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">rtol</span><span class="p">),</span>
            <span class="n">keep</span><span class="p">,</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tx</span><span class="p">)),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx</span><span class="p">)),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">n_points</span><span class="p">),</span>
        <span class="p">)</span> 

        <span class="k">return</span> <span class="n">intersection_points</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keep</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span></div></div>
</pre></div>

              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright [2020-2022] Daniel Kastinen, Juha Vierinen, Thomas Maynadie, Tom Grydeland.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>